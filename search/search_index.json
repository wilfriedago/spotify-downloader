{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"spotDL v4 \u00a4 Download your Spotify playlists and songs along with album art and metadata A new and improved version of spotDL: still the fastest, easiest and most accurate command-line music downloader Read the documentation on ReadTheDocs! Prerequisites \u00a4 Visual C++ 2019 redistributable (on Windows) Python 3.7 or above (added to PATH) YouTube Music must be available in your country for spotDL to work. This is because we use YouTube Music to filter search results. You can check if YouTube Music is available in your country, by visiting YouTube Music . Installation \u00a4 Refer to our Installation Guide for more details Python ( Recommended ) spotDL can be installed by running pip install spotdl . On some systems you might have to change pip to pip3 . Other options \u00a4 Prebuilt Executable You can download the latest version from from the Releases Tab On Termux curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh Arch There is an Arch User Repository (AUR) package for spotDL . Docker Build image: docker build -t spotdl . Launch container with spotDL parameters (see section below). You need to create mapped volume to access song files docker run --rm -v $( pwd ) :/music spotdl download [ trackUrl ] Installing FFmpeg \u00a4 If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. spotdl --download-ffmpeg will download FFmpeg to your spotDL installation directory. We reccomend the above option, but if you want to install FFmpeg system-wide, Windows Tutorial OSX - brew install ffmpeg Linux - sudo apt install ffmpeg or use your distro's package manager Usage \u00a4 To get started right away: spotdl download [ urls ] To start the Web UI: spotdl web You can run spotDL as a package if running it as a script doesn't work: python -m spotdl [ urls ] Further information can be found in our documentation \u00a4 Read the documentation on ReadTheDocs! Contributing \u00a4 Interested in contributing? Check out our CONTRIBUTING.md to find resources around contributing along with a guide on how to set up a development environment. License \u00a4 This project is Licensed under the MIT License.","title":"Home"},{"location":"#spotdl-v4","text":"Download your Spotify playlists and songs along with album art and metadata A new and improved version of spotDL: still the fastest, easiest and most accurate command-line music downloader Read the documentation on ReadTheDocs!","title":"spotDL v4"},{"location":"#prerequisites","text":"Visual C++ 2019 redistributable (on Windows) Python 3.7 or above (added to PATH) YouTube Music must be available in your country for spotDL to work. This is because we use YouTube Music to filter search results. You can check if YouTube Music is available in your country, by visiting YouTube Music .","title":"Prerequisites"},{"location":"#installation","text":"Refer to our Installation Guide for more details Python ( Recommended ) spotDL can be installed by running pip install spotdl . On some systems you might have to change pip to pip3 .","title":"Installation"},{"location":"#other-options","text":"Prebuilt Executable You can download the latest version from from the Releases Tab On Termux curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh Arch There is an Arch User Repository (AUR) package for spotDL . Docker Build image: docker build -t spotdl . Launch container with spotDL parameters (see section below). You need to create mapped volume to access song files docker run --rm -v $( pwd ) :/music spotdl download [ trackUrl ]","title":"Other options"},{"location":"#installing-ffmpeg","text":"If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. spotdl --download-ffmpeg will download FFmpeg to your spotDL installation directory. We reccomend the above option, but if you want to install FFmpeg system-wide, Windows Tutorial OSX - brew install ffmpeg Linux - sudo apt install ffmpeg or use your distro's package manager","title":"Installing FFmpeg"},{"location":"#usage","text":"To get started right away: spotdl download [ urls ] To start the Web UI: spotdl web You can run spotDL as a package if running it as a script doesn't work: python -m spotdl [ urls ]","title":"Usage"},{"location":"#further-information-can-be-found-in-our-documentation","text":"Read the documentation on ReadTheDocs!","title":"Further information can be found in our documentation"},{"location":"#contributing","text":"Interested in contributing? Check out our CONTRIBUTING.md to find resources around contributing along with a guide on how to set up a development environment.","title":"Contributing"},{"location":"#license","text":"This project is Licensed under the MIT License.","title":"License"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards \u00a4 Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities \u00a4 Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope \u00a4 This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spotdladmins@googlegroups.com . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines \u00a4 Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction \u00a4 Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning \u00a4 Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban \u00a4 Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban \u00a4 Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Code Of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spotdladmins@googlegroups.com . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"CODE_OF_CONDUCT/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"CODE_OF_CONDUCT/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Attribution"},{"location":"CONTRIBUTING/","text":"Contributing to spotdl \u00a4 First off, thanks for taking the time to contribute! \u2764\ufe0f All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for everyone involved. The community looks forward to your contributions. \ud83c\udf89 And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: Star the project Tweet about it Refer this project in your project's readme Mention the project at local meetups and tell your friends/colleagues Table of Contents \u00a4 I Have a Question I Want To Contribute Reporting Bugs Suggesting Enhancements Linting, Formatting and Type-checking Python Documentation Overview of the Project Structure Join The Project Team I Have a Question \u00a4 If you want to ask a question, we assume that you have read the available Documentation . Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first. If you then still feel the need to ask a question and need clarification, we recommend the following: Open an Issue . Provide as much context as you can about what you're running into. Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant. We will then take care of the issue as soon as possible. I Want To Contribute \u00a4 Legal Notice \u00a4 When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license. Reporting Bugs \u00a4 Before Submitting a Bug Report \u00a4 A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible. Make sure that you are using the latest version. Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation . If you are looking for support, you might want to check this section ). To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker . Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue. Collect information about the bug: Stack trace (Traceback) OS, Platform and Version (Windows, Linux, macOS, x86, ARM) Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant. Possibly your input and the output Can you reliably reproduce the issue? And can you also reproduce it with older versions? How Do I Submit a Good Bug Report? \u00a4 You must never report security related issues, vulnerabilities or bugs to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by discord to xnetcat#8144. We use GitHub issues to track bugs and errors. If you run into an issue with the project: Open an Issue . (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.) Explain the behavior you would expect and the actual behavior. Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case. Provide the information you collected in the previous section. Once it's filed: The project team will label the issue accordingly. A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as needs-repro . Bugs with the needs-repro tag will not be addressed until they are reproduced. If the team is able to reproduce the issue, it will be marked needs-fix , as well as possibly other tags (such as critical ), and the issue will be left to be implemented by someone . Suggesting Enhancements \u00a4 This section guides you through submitting an enhancement suggestion for spotdl, including completely new features and minor improvements to existing functionality . Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions. Before Submitting an Enhancement \u00a4 Make sure that you are using the latest version. Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration. Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one. Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library. How Do I Submit a Good Enhancement Suggestion? \u00a4 Enhancement suggestions are tracked as GitHub issues . Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you. You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. Explain why this enhancement would be useful to most spotdl users. You may also want to point out the other projects that solved it better and which could serve as inspiration. Developing \u00a4 Fork the repository on Github and then clone it. git clone [ your username ] /spotify-downloader cd spotify-downloader (Optional) Create a virtual environment python3 -m venv .venv Activate the virtual environment. - Linux: source .venv/bin/activate - Windows: .venv\\Scripts\\activate See Python's official venv docs for advanced virtual environment setup. Then, to install spotDL in-place and editable, run the following pip install -e . All changes will now affect the venv installation of the spotdl cli. Linting, Formatting and Type-checking \u00a4 We use pylint for linting and expect a score above 9 pylint --limit-inference-results 0 --fail-under 9 ./spotdl We use black for code formatting black ./spotdl We use mypy for type-checking and expect no errors at all To install type-stubs the first time around mypy --ignore-missing-imports --follow-imports silent --install-types --non-interactive ./spotdl mypy ./spotdl You can install these basic tools with pip install --force-reinstall --upgrade mypy black pylint Python Documentation \u00a4 Any submitted code is expected to have accompanying documentation mkdocs: generating documentation \u00a4 We generate our documentation with mkdocs pip install mkdocs mkdocs requires that all development packages are installed poetry install generate docs with mkdocs build --strict view docs live-time while editing with mkdocs serve DocString Formats \u00a4 For functions one-liner about functions purpose ### Args (optional) - arg_name: description ### Returns (optional) - return value description ### Errors (only if there are known unhandled Errors/thrown Errors) - known errors ### Notes (optional) - notes if any For Classes one-liner about class purpose ### Attributes - attribute: description ### Notes (optional) - notes if any For modules/package __init__ at max 3 lines about module/package purpose optional usage example for module/package preferably showcasing most commonly used functionality Notes about docstrings \u00a4 DocStrings are Inherited class A: def test(self): \"\"\"Docstring for A.\"\"\" pass class B(A): def test(self): pass # B.test.__doc__ acc. to normal python : None # B.test.__doc__ acc. to normal pdoc3 : Docstring for A. You can write DocStrings for variables with #: comment above the variable #: an example variable to demonstrate DocStrings example_var_1 = 1 You can use the reST directives ..math:: and ..image:: Markdown formatting \u00a4 Markdown is formatted with mdformat-gfm and indexes are auto-generated with mdformat-toc pip install mdformat-gfm mdformat-toc Create an Index using the following comment, the index will be updated when mdformat is run <!-- mdformat-toc start --no-anchors --> Preferably use empty lines between points on ordered & un-ordered lists Format your markdown using mdformat --wrap 95 --number ./ Overview of the Project Structure \u00a4 sub-package purpose utils Contains commonly used functions types Custom data types used in the spotdl project providers Different Providers to obtain info (like song details) from download Download manager console Different user-facing operations like download, preload and web-ui __init__ Contains spotdl class that simplifies the download process Join The Project Team \u00a4 Attribution \u00a4 This guide is based on the contributing-gen . Make your own !","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-spotdl","text":"First off, thanks for taking the time to contribute! \u2764\ufe0f All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for everyone involved. The community looks forward to your contributions. \ud83c\udf89 And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: Star the project Tweet about it Refer this project in your project's readme Mention the project at local meetups and tell your friends/colleagues","title":"Contributing to spotdl"},{"location":"CONTRIBUTING/#table-of-contents","text":"I Have a Question I Want To Contribute Reporting Bugs Suggesting Enhancements Linting, Formatting and Type-checking Python Documentation Overview of the Project Structure Join The Project Team","title":"Table of Contents"},{"location":"CONTRIBUTING/#i-have-a-question","text":"If you want to ask a question, we assume that you have read the available Documentation . Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first. If you then still feel the need to ask a question and need clarification, we recommend the following: Open an Issue . Provide as much context as you can about what you're running into. Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant. We will then take care of the issue as soon as possible.","title":"I Have a Question"},{"location":"CONTRIBUTING/#i-want-to-contribute","text":"","title":"I Want To Contribute"},{"location":"CONTRIBUTING/#legal-notice","text":"When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.","title":"Legal Notice "},{"location":"CONTRIBUTING/#reporting-bugs","text":"","title":"Reporting Bugs"},{"location":"CONTRIBUTING/#before-submitting-a-bug-report","text":"A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible. Make sure that you are using the latest version. Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation . If you are looking for support, you might want to check this section ). To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker . Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue. Collect information about the bug: Stack trace (Traceback) OS, Platform and Version (Windows, Linux, macOS, x86, ARM) Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant. Possibly your input and the output Can you reliably reproduce the issue? And can you also reproduce it with older versions?","title":"Before Submitting a Bug Report"},{"location":"CONTRIBUTING/#how-do-i-submit-a-good-bug-report","text":"You must never report security related issues, vulnerabilities or bugs to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by discord to xnetcat#8144. We use GitHub issues to track bugs and errors. If you run into an issue with the project: Open an Issue . (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.) Explain the behavior you would expect and the actual behavior. Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case. Provide the information you collected in the previous section. Once it's filed: The project team will label the issue accordingly. A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as needs-repro . Bugs with the needs-repro tag will not be addressed until they are reproduced. If the team is able to reproduce the issue, it will be marked needs-fix , as well as possibly other tags (such as critical ), and the issue will be left to be implemented by someone .","title":"How Do I Submit a Good Bug Report?"},{"location":"CONTRIBUTING/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion for spotdl, including completely new features and minor improvements to existing functionality . Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.","title":"Suggesting Enhancements"},{"location":"CONTRIBUTING/#before-submitting-an-enhancement","text":"Make sure that you are using the latest version. Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration. Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one. Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.","title":"Before Submitting an Enhancement"},{"location":"CONTRIBUTING/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues . Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you. You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. Explain why this enhancement would be useful to most spotdl users. You may also want to point out the other projects that solved it better and which could serve as inspiration.","title":"How Do I Submit a Good Enhancement Suggestion?"},{"location":"CONTRIBUTING/#developing","text":"Fork the repository on Github and then clone it. git clone [ your username ] /spotify-downloader cd spotify-downloader (Optional) Create a virtual environment python3 -m venv .venv Activate the virtual environment. - Linux: source .venv/bin/activate - Windows: .venv\\Scripts\\activate See Python's official venv docs for advanced virtual environment setup. Then, to install spotDL in-place and editable, run the following pip install -e . All changes will now affect the venv installation of the spotdl cli.","title":"Developing"},{"location":"CONTRIBUTING/#linting-formatting-and-type-checking","text":"We use pylint for linting and expect a score above 9 pylint --limit-inference-results 0 --fail-under 9 ./spotdl We use black for code formatting black ./spotdl We use mypy for type-checking and expect no errors at all To install type-stubs the first time around mypy --ignore-missing-imports --follow-imports silent --install-types --non-interactive ./spotdl mypy ./spotdl You can install these basic tools with pip install --force-reinstall --upgrade mypy black pylint","title":"Linting, Formatting and Type-checking"},{"location":"CONTRIBUTING/#python-documentation","text":"Any submitted code is expected to have accompanying documentation","title":"Python Documentation"},{"location":"CONTRIBUTING/#mkdocs-generating-documentation","text":"We generate our documentation with mkdocs pip install mkdocs mkdocs requires that all development packages are installed poetry install generate docs with mkdocs build --strict view docs live-time while editing with mkdocs serve","title":"mkdocs: generating documentation"},{"location":"CONTRIBUTING/#docstring-formats","text":"For functions one-liner about functions purpose ### Args (optional) - arg_name: description ### Returns (optional) - return value description ### Errors (only if there are known unhandled Errors/thrown Errors) - known errors ### Notes (optional) - notes if any For Classes one-liner about class purpose ### Attributes - attribute: description ### Notes (optional) - notes if any For modules/package __init__ at max 3 lines about module/package purpose optional usage example for module/package preferably showcasing most commonly used functionality","title":"DocString Formats"},{"location":"CONTRIBUTING/#notes-about-docstrings","text":"DocStrings are Inherited class A: def test(self): \"\"\"Docstring for A.\"\"\" pass class B(A): def test(self): pass # B.test.__doc__ acc. to normal python : None # B.test.__doc__ acc. to normal pdoc3 : Docstring for A. You can write DocStrings for variables with #: comment above the variable #: an example variable to demonstrate DocStrings example_var_1 = 1 You can use the reST directives ..math:: and ..image::","title":"Notes about docstrings"},{"location":"CONTRIBUTING/#markdown-formatting","text":"Markdown is formatted with mdformat-gfm and indexes are auto-generated with mdformat-toc pip install mdformat-gfm mdformat-toc Create an Index using the following comment, the index will be updated when mdformat is run <!-- mdformat-toc start --no-anchors --> Preferably use empty lines between points on ordered & un-ordered lists Format your markdown using mdformat --wrap 95 --number ./","title":"Markdown formatting"},{"location":"CONTRIBUTING/#overview-of-the-project-structure","text":"sub-package purpose utils Contains commonly used functions types Custom data types used in the spotdl project providers Different Providers to obtain info (like song details) from download Download manager console Different user-facing operations like download, preload and web-ui __init__ Contains spotdl class that simplifies the download process","title":"Overview of the Project Structure"},{"location":"CONTRIBUTING/#join-the-project-team","text":"","title":"Join The Project Team"},{"location":"CONTRIBUTING/#attribution","text":"This guide is based on the contributing-gen . Make your own !","title":"Attribution"},{"location":"installation/","text":"spotDL Installation Guide \u00a4 spotDL is a free and open source tool that downloads your Spotify playlists & music The fastest, easiest, and most accurate command-line music downloader Install via Python \u00a4 This is our recommended installation method. If you are on Windows, Install Visual C++ Redistributible (link below) and then proceed to install Python & FFmpeg Prerequisites to spotDL \u00a4 Visual C++ 2019 redistributable (on Windows) Python 3.7 or above (added to PATH) FFmpeg 4.2 or above (added to PATH) Install Python to PATH \u00a4 We recommend installing the latest version of Python When installing Python , ensure to select \" Add to PATH \". Installing spotDL \u00a4 If you are not on Windows (e.g. OSX/UNIX), replace pip with pip3 and python with python3 in all commands. Firstly, open a terminal. On Windows: Command Prompt, OSX: \"Terminal\", *UNIX: Bash or Zsh. Verify you have installed Python correctly via python -V . Ensure you have v3.7 or greater. Next, install spotDL by typing the following pip install spotdl Installing FFmpeg \u00a4 If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. spotdl --download-ffmpeg will download FFmpeg to your spotDL installation directory. We reccomend the above option, but if you want to install FFmpeg system-wide, Windows Tutorial OSX - brew install ffmpeg Linux - sudo apt install ffmpeg or use your distro's package manager If you require further help, ask in our Discord Server Using Prebuilt Executable \u00a4 Download the executable \u00a4 You can download the latest version from from the Releases Tab Running Web UI \u00a4 Web UI will start by default if no arguments are passed to the command line (after double-clicking for example) Running the CLI \u00a4 To use the command line interface just open your terminal and run ./spotdl-vX.X.X operation [urls] Docker Setup \u00a4 spotDL provides a Docker image. Install Docker: https://docs.docker.com/engine/installation/ Install Docker Compose: https://docs.docker.com/compose/install/ Docker documentation: https://docs.docker.com/ Built-in Docker Image \u00a4 Build docker image docker build -t spotdl . List spotdl options: docker run --rm spotdl --help Download a song: docker run --rm -v $(pwd):/music spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b Docker Hub Image \u00a4 Pull docker image from Docker hub: docker pull spotdl/spotify-downloader Download a song using Docker image: docker run --rm -v $(pwd):/music spotdl/spotify-downloader download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b Create a Docker container docker create \\ --name=spotdl \\ -v <path to data>:/music \\ spotdl/spotify-downloader Docker Compose \u00a4 Create a container using Docker Compose: docker-compose up --no-start Download a song using Docker compose: docker-compose run --rm spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b Other Installation Methods \u00a4 Termux \u00a4 We have a dedicated Termux installation script curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh Arch User Repository (AUR) package \u00a4 You can find the AUR Package here Where does spotDL download songs? \u00a4 spotDL downloads files to the folder where you ran spotDL from. Open pwsh/powershell/cmd/terminal/similar in the folder you want files to download to, or cd to desired folder. Windows Shortcut: Navigate to the folder you want the files to download to. SHIFT + RIGHT CLICK , then select \"Open PowerShell window here\" We have a public Discord server at discord.gg/xCa23pwJWY ! \u00a4","title":"Installation"},{"location":"installation/#spotdl-installation-guide","text":"spotDL is a free and open source tool that downloads your Spotify playlists & music The fastest, easiest, and most accurate command-line music downloader","title":"spotDL Installation Guide"},{"location":"installation/#install-via-python","text":"This is our recommended installation method. If you are on Windows, Install Visual C++ Redistributible (link below) and then proceed to install Python & FFmpeg","title":"Install via Python"},{"location":"installation/#prerequisites-to-spotdl","text":"Visual C++ 2019 redistributable (on Windows) Python 3.7 or above (added to PATH) FFmpeg 4.2 or above (added to PATH)","title":"Prerequisites to spotDL"},{"location":"installation/#install-python-to-path","text":"We recommend installing the latest version of Python When installing Python , ensure to select \" Add to PATH \".","title":"Install Python to PATH"},{"location":"installation/#installing-spotdl","text":"If you are not on Windows (e.g. OSX/UNIX), replace pip with pip3 and python with python3 in all commands. Firstly, open a terminal. On Windows: Command Prompt, OSX: \"Terminal\", *UNIX: Bash or Zsh. Verify you have installed Python correctly via python -V . Ensure you have v3.7 or greater. Next, install spotDL by typing the following pip install spotdl","title":"Installing spotDL"},{"location":"installation/#installing-ffmpeg","text":"If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. spotdl --download-ffmpeg will download FFmpeg to your spotDL installation directory. We reccomend the above option, but if you want to install FFmpeg system-wide, Windows Tutorial OSX - brew install ffmpeg Linux - sudo apt install ffmpeg or use your distro's package manager If you require further help, ask in our Discord Server","title":"Installing FFmpeg"},{"location":"installation/#using-prebuilt-executable","text":"","title":"Using Prebuilt Executable"},{"location":"installation/#download-the-executable","text":"You can download the latest version from from the Releases Tab","title":"Download the executable"},{"location":"installation/#running-web-ui","text":"Web UI will start by default if no arguments are passed to the command line (after double-clicking for example)","title":"Running Web UI"},{"location":"installation/#running-the-cli","text":"To use the command line interface just open your terminal and run ./spotdl-vX.X.X operation [urls]","title":"Running the CLI"},{"location":"installation/#docker-setup","text":"spotDL provides a Docker image. Install Docker: https://docs.docker.com/engine/installation/ Install Docker Compose: https://docs.docker.com/compose/install/ Docker documentation: https://docs.docker.com/","title":"Docker Setup"},{"location":"installation/#built-in-docker-image","text":"Build docker image docker build -t spotdl . List spotdl options: docker run --rm spotdl --help Download a song: docker run --rm -v $(pwd):/music spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b","title":"Built-in Docker Image"},{"location":"installation/#docker-hub-image","text":"Pull docker image from Docker hub: docker pull spotdl/spotify-downloader Download a song using Docker image: docker run --rm -v $(pwd):/music spotdl/spotify-downloader download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b Create a Docker container docker create \\ --name=spotdl \\ -v <path to data>:/music \\ spotdl/spotify-downloader","title":"Docker Hub Image"},{"location":"installation/#docker-compose","text":"Create a container using Docker Compose: docker-compose up --no-start Download a song using Docker compose: docker-compose run --rm spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b","title":"Docker Compose"},{"location":"installation/#other-installation-methods","text":"","title":"Other Installation Methods"},{"location":"installation/#termux","text":"We have a dedicated Termux installation script curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh","title":"Termux"},{"location":"installation/#arch-user-repository-aur-package","text":"You can find the AUR Package here","title":"Arch User Repository (AUR) package"},{"location":"installation/#where-does-spotdl-download-songs","text":"spotDL downloads files to the folder where you ran spotDL from. Open pwsh/powershell/cmd/terminal/similar in the folder you want files to download to, or cd to desired folder. Windows Shortcut: Navigate to the folder you want the files to download to. SHIFT + RIGHT CLICK , then select \"Open PowerShell window here\"","title":"Where does spotDL download songs?"},{"location":"installation/#we-have-a-public-discord-server-at-discordggxca23pwjwy","text":"","title":"We have a public Discord server at discord.gg/xCa23pwJWY!"},{"location":"troubleshooting/","text":"Troubleshooting / FAQ Guide \u00a4 As common issues or questions are encountered solutions will be added to this guide. 'spotdl' is not recognized \u00a4 Python/(site packages) is not added to PATH correctly. You need to install Python from https://www.python.org/downloads/ Or you are using python from microsoft store. If so uninstall it and restart cmd. If this doesn't work reinstall python. Error message \u00a4 'spotdl' is not recognized as an internal or external command, operable program or batch file. Solution \u00a4 Ensure to add to PATH when installing: spotdl: command not found \u00a4 If you see this error after installing spotdl, that means that the bin (Binaries) folder is not on $PATH Solution \u00a4 .bashrc \u00a4 Add export PATH=~/.local/bin:$PATH at the bottom of ~/.bashrc Then run source ~/.bashrc .zshrc \u00a4 Add export PATH=~/.local/bin:$PATH at the bottom of ~/.zshrc Then run source ~/.zshrc pkg_resources.DistributionNotFound \u00a4 Sometimes not all packages are installed but are required by yt-dlp for example: brotli or websockets Error Message \u00a4 pkg_resources.DistributionNotFound: The 'websockets' distribution was not found and is required by yt-dlp Solution \u00a4 pip install brotli websockets yt-dlp -U HTTP Error 404 \u00a4 https://github.com/plamere/spotipy/issues/795#issuecomment-1100321148 Error Message \u00a4 HTTP Error for GET to URL with Params: {} returned 404 due to None Solution \u00a4 Update spotdl to the latest version which contains workaround. pip install -U spotdl ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] \u00a4 https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error Error Message \u00a4 urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847)> Solution \u00a4 https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error RecursionError \u00a4 https://github.com/spotDL/spotify-downloader/issues/1493 Error Message \u00a4 RecursionError: maximum recursion depth exceeded Solution \u00a4 Update spotdl pip install spotdl -U RuntimeWarning \u00a4 This happens when running spotdl using python -m . Error Message \u00a4 RuntimeWarning: 'spotdl.__main__' found in sys.modules after import of package 'spotdl', but prior to execution of 'spotdl.__main__'; this may result in unpredictable behaviour warn(RuntimeWarning(msg)) Solution \u00a4 You can ignore this error or just run spotdl directly Not found '_raw_ecb.so' \u00a4 This error is specific for M1 Macs only. https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738 Error Message \u00a4 aise OSError(\"Cannot load native module '%s': %s\" % (name, \", \".join(attempts))) OSError: Cannot load native module 'Cryptodome.Cipher._raw_ecb': Not found '_raw_ecb.cpython-39-darwin.so', Cannot load '_raw_ecb.abi3.so': dlopen(/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so, 6): no suitable image found. Did find: /opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture /opt/homebrew/lib/python3.9/site-packages/Cryptodome/Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture, Not found '_raw_ecb.so' Solution \u00a4 Possible solutions: https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting-faq-guide","text":"As common issues or questions are encountered solutions will be added to this guide.","title":"Troubleshooting / FAQ Guide"},{"location":"troubleshooting/#spotdl-is-not-recognized","text":"Python/(site packages) is not added to PATH correctly. You need to install Python from https://www.python.org/downloads/ Or you are using python from microsoft store. If so uninstall it and restart cmd. If this doesn't work reinstall python.","title":"'spotdl' is not recognized"},{"location":"troubleshooting/#error-message","text":"'spotdl' is not recognized as an internal or external command, operable program or batch file.","title":"Error message"},{"location":"troubleshooting/#solution","text":"Ensure to add to PATH when installing:","title":"Solution"},{"location":"troubleshooting/#spotdl-command-not-found","text":"If you see this error after installing spotdl, that means that the bin (Binaries) folder is not on $PATH","title":"spotdl: command not found"},{"location":"troubleshooting/#solution_1","text":"","title":"Solution"},{"location":"troubleshooting/#bashrc","text":"Add export PATH=~/.local/bin:$PATH at the bottom of ~/.bashrc Then run source ~/.bashrc","title":".bashrc"},{"location":"troubleshooting/#zshrc","text":"Add export PATH=~/.local/bin:$PATH at the bottom of ~/.zshrc Then run source ~/.zshrc","title":".zshrc"},{"location":"troubleshooting/#pkg_resourcesdistributionnotfound","text":"Sometimes not all packages are installed but are required by yt-dlp for example: brotli or websockets","title":"pkg_resources.DistributionNotFound"},{"location":"troubleshooting/#error-message_1","text":"pkg_resources.DistributionNotFound: The 'websockets' distribution was not found and is required by yt-dlp","title":"Error Message"},{"location":"troubleshooting/#solution_2","text":"pip install brotli websockets yt-dlp -U","title":"Solution"},{"location":"troubleshooting/#http-error-404","text":"https://github.com/plamere/spotipy/issues/795#issuecomment-1100321148","title":"HTTP Error 404"},{"location":"troubleshooting/#error-message_2","text":"HTTP Error for GET to URL with Params: {} returned 404 due to None","title":"Error Message"},{"location":"troubleshooting/#solution_3","text":"Update spotdl to the latest version which contains workaround. pip install -U spotdl","title":"Solution"},{"location":"troubleshooting/#sslsslerror-ssl-certificate_verify_failed","text":"https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error","title":"ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]"},{"location":"troubleshooting/#error-message_3","text":"urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847)>","title":"Error Message"},{"location":"troubleshooting/#solution_4","text":"https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error","title":"Solution"},{"location":"troubleshooting/#recursionerror","text":"https://github.com/spotDL/spotify-downloader/issues/1493","title":"RecursionError"},{"location":"troubleshooting/#error-message_4","text":"RecursionError: maximum recursion depth exceeded","title":"Error Message"},{"location":"troubleshooting/#solution_5","text":"Update spotdl pip install spotdl -U","title":"Solution"},{"location":"troubleshooting/#runtimewarning","text":"This happens when running spotdl using python -m .","title":"RuntimeWarning"},{"location":"troubleshooting/#error-message_5","text":"RuntimeWarning: 'spotdl.__main__' found in sys.modules after import of package 'spotdl', but prior to execution of 'spotdl.__main__'; this may result in unpredictable behaviour warn(RuntimeWarning(msg))","title":"Error Message"},{"location":"troubleshooting/#solution_6","text":"You can ignore this error or just run spotdl directly","title":"Solution"},{"location":"troubleshooting/#not-found-_raw_ecbso","text":"This error is specific for M1 Macs only. https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738","title":"Not found '_raw_ecb.so'"},{"location":"troubleshooting/#error-message_6","text":"aise OSError(\"Cannot load native module '%s': %s\" % (name, \", \".join(attempts))) OSError: Cannot load native module 'Cryptodome.Cipher._raw_ecb': Not found '_raw_ecb.cpython-39-darwin.so', Cannot load '_raw_ecb.abi3.so': dlopen(/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so, 6): no suitable image found. Did find: /opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture /opt/homebrew/lib/python3.9/site-packages/Cryptodome/Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture, Not found '_raw_ecb.so'","title":"Error Message"},{"location":"troubleshooting/#solution_7","text":"Possible solutions: https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738","title":"Solution"},{"location":"usage/","text":"spotDL usage examples \u00a4 Downloading \u00a4 Song To download a song, run spotdl download [ trackUrl ] example: spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b Album To download an album, run spotdl download [ albumUrl ] example: spotdl download https://open.spotify.com/album/4yP0hdKOZPNshxUOjY0cZj Playlist To download a playlist, run spotdl download [ playlistUrl ] example: spotdl download https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID Artist To download all songs from an artist run spotdl download [ artistUrl ] example: spotdl download https://open.spotify.com/artist/1Xyo4u8uXC1ZmMpatF05PJ Search To search for and download a song, run, with quotation marks spotdl download '[songQuery]' example: spotdl download 'The Weeknd - Blinding Lights' YouTube link with Spotify metadata To download YouTube video with metadata from Spotify, run Noting the quote \" are required spotdl download \"YouTubeURL|SpotifyURL\" example: spotdl download \"https://www.youtube.com/watch?v=XXYlFuWEuKI|https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b?si=b5c0790edc8f4904\" You can queue up multiple download tasks by separating the arguments with spaces spotdl download [ songQuery1 ] [ albumUrl ] [ songQuery2 ] ... ( order does not matter ) example: spotdl download 'The Weeknd - Blinding Lights' https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID ... Syncing \u00a4 Sync function for the console. Keep local files up to date with playlists/albums/etc. This will download new songs and remove the ones that are no longer present in the playlists/albums/etc Initialise Synchronisation To create the sync file run spotdl sync [ query ] --save-file [ fileName ] example: spotdl sync https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID --save-file 'the-weeknd.sync.spotdl' Note: The sync file has to end with .spotdl Syncing To sync the songs run spotdl sync [ fileName ] example: spotdl sync 'the-weeknd.sync.spotdl' Saving \u00a4 Saves the songs metadata to a file for further use. spotdl save [ query ] --save-file [ fileName ] example: spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl' Preloading Preload the download url to speed up the download process. spotdl save [ query ] --save-file [ fileName ] --preload example: spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl' --preload Web UI (User Interface) \u00a4 To start the web UI, run spotdl web Config file \u00a4 Config file location \u00a4 The config file is located at C:\\Users\\user\\.spotdl\\config.json or ~/.spotdl/config.json under linux Generate a config file \u00a4 To generate a config file, run spotdl --generate-config Note: This will overwrite the existing config file. Loading config \u00a4 Config file gets loaded automatically if it already exists, or if you've passed --config flag If you don't want config to load automatically change load_config option in config file to false { \"load_config\" : false } Default config \u00a4 { \"load_config\" : true , \"log_level\" : \"INFO\" , \"simple_tui\" : false , \"cache_path\" : \"C:\\\\Users\\\\username\\\\.spotdl\\\\.spotipy\" , \"audio_providers\" : [ \"youtube-music\" ], \"lyrics_providers\" : [ \"musixmatch\" , \"genius\" ], \"ffmpeg\" : \"ffmpeg\" , \"bitrate\" : null , \"ffmpeg_args\" : null , \"format\" : \"mp3\" , \"save_file\" : null , \"m3u\" : null , \"output\" : \"{artists} - {title}.{output-ext}\" , \"overwrite\" : \"skip\" , \"client_id\" : \"5f573c9620494bae87890c0f08a60293\" , \"client_secret\" : \"212476d9b0f3472eaa762d90b19b0ba8\" , \"auth_token\" : null , \"user_auth\" : false , \"search_query\" : null , \"filter_results\" : true , \"threads\" : 4 , \"no_cache\" : false , \"cookie_file\" : null , \"headless\" : false , \"restrict\" : false , \"print_errors\" : false , \"sponsor_block\" : false , \"preload\" : false } CLI (Command Line Interface) \u00a4 Command line options \u00a4 options: -h, --help show this help message and exit Main options: {download,save,web,sync} The operation to perform. download: Download the songs to the disk and embed metadata. save: Saves the songs metadata to a file for further use. web: Starts a web interface to simplify the download process. sync: removes songs that are no longer present, downloads new ones query Spotify URL for a song/playlist/album/artist/etc. to download.For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL' --audio [{youtube,youtube-music} ...] The audio provider to use. You can provide more than one for fallback. --lyrics [{genius,musixmatch,azlyrics} ...] The lyrics provider to use. You can provide more than one for fallback. --config Use the config file to download songs. It's located under C:\\Users\\user\\.spotdl\\config.json or ~/.spotdl/config.json under linux --search-query SEARCH_QUERY The search query to use, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year}, {original- date}, {track-number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext} --dont-filter-results Disable filtering results. Spotify options: --user-auth Login to Spotify using OAuth. --client-id CLIENT_ID The client id to use when logging in to Spotify. --client-secret CLIENT_SECRET The client secret to use when logging in to Spotify. --auth-token AUTH_TOKEN The authorisation token to use directly to log in to Spotify. --cache-path CACHE_PATH The path where spotipy cache file will be stored. --no-cache Disable caching (both requests and token). --cookie-file COOKIE_FILE Path to cookies file. FFmpeg options: --ffmpeg FFMPEG The ffmpeg executable to use. --threads THREADS The number of threads to use when downloading songs. --bitrate {8k,16k,24k,32k,40k,48k,64k,80k,96k,112k,128k,160k,192k,224k,256k,320k} The constant bitrate to use for the output file. --ffmpeg-args FFMPEG_ARGS Additional ffmpeg arguments passed as a string. Output options: --format {mp3,flac,ogg,opus,m4a} The format to download the song in. --save-file SAVE_FILE The file to save/load the songs data from/to. It has to end with .spotdl. If combined with the download operation, it will save the songs data to the file. Required for save/preload/sync --preload Preload the download url to speed up the download process. --output OUTPUT Specify the downloaded file name format, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year}, {original-date}, {track-number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext} --m3u M3U Name of the m3u file to save the songs to. --overwrite {skip,force} Overwrite existing files. --restrict Restrict filenames to ASCII only --print-errors Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist --sponsor-block Use the sponsor block to download songs from yt/ytm. Misc options: --log-level {CRITICAL,FATAL,ERROR,WARN,WARNING,INFO,DEBUG,NOTSET} Select log level. --simple-tui Use a simple tui. --headless Run in headless mode. Other options: --download-ffmpeg Download ffmpeg to spotdl directory. --generate-config Generate a config file. This will overwrite current config if present. --check-for-updates Check for new version. --profile Run in profile mode. Useful for debugging. --version, -v Show the version number and exit.","title":"Usage"},{"location":"usage/#spotdl-usage-examples","text":"","title":"spotDL usage examples"},{"location":"usage/#downloading","text":"Song To download a song, run spotdl download [ trackUrl ] example: spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b Album To download an album, run spotdl download [ albumUrl ] example: spotdl download https://open.spotify.com/album/4yP0hdKOZPNshxUOjY0cZj Playlist To download a playlist, run spotdl download [ playlistUrl ] example: spotdl download https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID Artist To download all songs from an artist run spotdl download [ artistUrl ] example: spotdl download https://open.spotify.com/artist/1Xyo4u8uXC1ZmMpatF05PJ Search To search for and download a song, run, with quotation marks spotdl download '[songQuery]' example: spotdl download 'The Weeknd - Blinding Lights' YouTube link with Spotify metadata To download YouTube video with metadata from Spotify, run Noting the quote \" are required spotdl download \"YouTubeURL|SpotifyURL\" example: spotdl download \"https://www.youtube.com/watch?v=XXYlFuWEuKI|https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b?si=b5c0790edc8f4904\" You can queue up multiple download tasks by separating the arguments with spaces spotdl download [ songQuery1 ] [ albumUrl ] [ songQuery2 ] ... ( order does not matter ) example: spotdl download 'The Weeknd - Blinding Lights' https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID ...","title":"Downloading"},{"location":"usage/#syncing","text":"Sync function for the console. Keep local files up to date with playlists/albums/etc. This will download new songs and remove the ones that are no longer present in the playlists/albums/etc Initialise Synchronisation To create the sync file run spotdl sync [ query ] --save-file [ fileName ] example: spotdl sync https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID --save-file 'the-weeknd.sync.spotdl' Note: The sync file has to end with .spotdl Syncing To sync the songs run spotdl sync [ fileName ] example: spotdl sync 'the-weeknd.sync.spotdl'","title":"Syncing"},{"location":"usage/#saving","text":"Saves the songs metadata to a file for further use. spotdl save [ query ] --save-file [ fileName ] example: spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl' Preloading Preload the download url to speed up the download process. spotdl save [ query ] --save-file [ fileName ] --preload example: spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl' --preload","title":"Saving"},{"location":"usage/#web-ui-user-interface","text":"To start the web UI, run spotdl web","title":"Web UI (User Interface)"},{"location":"usage/#config-file","text":"","title":"Config file"},{"location":"usage/#config-file-location","text":"The config file is located at C:\\Users\\user\\.spotdl\\config.json or ~/.spotdl/config.json under linux","title":"Config file location"},{"location":"usage/#generate-a-config-file","text":"To generate a config file, run spotdl --generate-config Note: This will overwrite the existing config file.","title":"Generate a config file"},{"location":"usage/#loading-config","text":"Config file gets loaded automatically if it already exists, or if you've passed --config flag If you don't want config to load automatically change load_config option in config file to false { \"load_config\" : false }","title":"Loading config"},{"location":"usage/#default-config","text":"{ \"load_config\" : true , \"log_level\" : \"INFO\" , \"simple_tui\" : false , \"cache_path\" : \"C:\\\\Users\\\\username\\\\.spotdl\\\\.spotipy\" , \"audio_providers\" : [ \"youtube-music\" ], \"lyrics_providers\" : [ \"musixmatch\" , \"genius\" ], \"ffmpeg\" : \"ffmpeg\" , \"bitrate\" : null , \"ffmpeg_args\" : null , \"format\" : \"mp3\" , \"save_file\" : null , \"m3u\" : null , \"output\" : \"{artists} - {title}.{output-ext}\" , \"overwrite\" : \"skip\" , \"client_id\" : \"5f573c9620494bae87890c0f08a60293\" , \"client_secret\" : \"212476d9b0f3472eaa762d90b19b0ba8\" , \"auth_token\" : null , \"user_auth\" : false , \"search_query\" : null , \"filter_results\" : true , \"threads\" : 4 , \"no_cache\" : false , \"cookie_file\" : null , \"headless\" : false , \"restrict\" : false , \"print_errors\" : false , \"sponsor_block\" : false , \"preload\" : false }","title":"Default config"},{"location":"usage/#cli-command-line-interface","text":"","title":"CLI (Command Line Interface)"},{"location":"usage/#command-line-options","text":"options: -h, --help show this help message and exit Main options: {download,save,web,sync} The operation to perform. download: Download the songs to the disk and embed metadata. save: Saves the songs metadata to a file for further use. web: Starts a web interface to simplify the download process. sync: removes songs that are no longer present, downloads new ones query Spotify URL for a song/playlist/album/artist/etc. to download.For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL' --audio [{youtube,youtube-music} ...] The audio provider to use. You can provide more than one for fallback. --lyrics [{genius,musixmatch,azlyrics} ...] The lyrics provider to use. You can provide more than one for fallback. --config Use the config file to download songs. It's located under C:\\Users\\user\\.spotdl\\config.json or ~/.spotdl/config.json under linux --search-query SEARCH_QUERY The search query to use, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year}, {original- date}, {track-number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext} --dont-filter-results Disable filtering results. Spotify options: --user-auth Login to Spotify using OAuth. --client-id CLIENT_ID The client id to use when logging in to Spotify. --client-secret CLIENT_SECRET The client secret to use when logging in to Spotify. --auth-token AUTH_TOKEN The authorisation token to use directly to log in to Spotify. --cache-path CACHE_PATH The path where spotipy cache file will be stored. --no-cache Disable caching (both requests and token). --cookie-file COOKIE_FILE Path to cookies file. FFmpeg options: --ffmpeg FFMPEG The ffmpeg executable to use. --threads THREADS The number of threads to use when downloading songs. --bitrate {8k,16k,24k,32k,40k,48k,64k,80k,96k,112k,128k,160k,192k,224k,256k,320k} The constant bitrate to use for the output file. --ffmpeg-args FFMPEG_ARGS Additional ffmpeg arguments passed as a string. Output options: --format {mp3,flac,ogg,opus,m4a} The format to download the song in. --save-file SAVE_FILE The file to save/load the songs data from/to. It has to end with .spotdl. If combined with the download operation, it will save the songs data to the file. Required for save/preload/sync --preload Preload the download url to speed up the download process. --output OUTPUT Specify the downloaded file name format, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year}, {original-date}, {track-number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext} --m3u M3U Name of the m3u file to save the songs to. --overwrite {skip,force} Overwrite existing files. --restrict Restrict filenames to ASCII only --print-errors Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist --sponsor-block Use the sponsor block to download songs from yt/ytm. Misc options: --log-level {CRITICAL,FATAL,ERROR,WARN,WARNING,INFO,DEBUG,NOTSET} Select log level. --simple-tui Use a simple tui. --headless Run in headless mode. Other options: --download-ffmpeg Download ffmpeg to spotdl directory. --generate-config Generate a config file. This will overwrite current config if present. --check-for-updates Check for new version. --profile Run in profile mode. Useful for debugging. --version, -v Show the version number and exit.","title":"Command line options"},{"location":"reference/","text":"Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class Spotdl ( client_id , client_secret , user_auth = False , cache_path = None , no_cache = False , headless = False , audio_providers = None , lyrics_providers = None , ffmpeg = 'ffmpeg' , bitrate = None , ffmpeg_args = None , output_format = 'mp3' , threads = 4 , output = '.' , save_file = None , overwrite = 'skip' , cookie_file = None , filter_results = True , search_query = None , log_level = 'INFO' , simple_tui = False , loop = None , restrict = False , print_errors = False , sponsor_block = False ) \u00a4 Spotdl class, which simplifies the process of downloading songs from Spotify. from spotdl import Spotdl spotdl = Spotdl ( client_id = 'your-client-id' , client_secret = 'your-client-secret' ) songs = spotdl . search ([ 'joji - test drive' , 'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT' ]) results = spotdl . download_songs ( songs ) song , path = spotd . download ( songs [ 0 ]) Arguments \u00a4 client_id: Spotify client id client_secret: Spotify client secret user_auth: If true, user will be prompted to authenticate cache_path: Path to cache directory no_cache: If true, no cache will be used headless: If true, no browser will be opened audio_providers: The audio providers to use. lyrics_providers: The lyrics providers to use. ffmpeg: The ffmpeg executable to use. variable_bitrate: The variable bitrate to use. constant_bitrate: The constant bitrate to use. ffmpeg_args: The ffmpeg arguments to use. output_format: The output format to use. threads: The number of threads to use. output: The output directory to use. save_file: The save file to use when saving/loading song metadata. overwrite: The overwrite mode to use (force/skip). cookie_file: The cookie file to use for yt-dlp. filter_results: Whether to filter results. search_query: The search query to use. log_level: The log level to use. simple_tui: Whether to use simple tui. loop: The event loop to use. restrict: Whether to restrict the filename to ASCII characters. print_errors: Whether to print errors on exit. sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. Notes \u00a4 search-query uses the same format as output . Source code in spotdl/__init__.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def __init__ ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : Optional [ str ] = None , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Spotdl class ### Arguments - client_id: Spotify client id - client_secret: Spotify client secret - user_auth: If true, user will be prompted to authenticate - cache_path: Path to cache directory - no_cache: If true, no cache will be used - headless: If true, no browser will be opened - audio_providers: The audio providers to use. - lyrics_providers: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] # Initialize spotify client SpotifyClient . init ( client_id = client_id , client_secret = client_secret , user_auth = user_auth , cache_path = cache_path , no_cache = no_cache , open_browser = not headless , ) # Initialize downloader self . downloader = Downloader ( audio_providers = audio_providers , lyrics_providers = lyrics_providers , search_query = search_query , ffmpeg = ffmpeg , bitrate = bitrate , ffmpeg_args = ffmpeg_args , output_format = output_format , threads = threads , output = output , save_file = save_file , overwrite = overwrite , cookie_file = cookie_file , filter_results = filter_results , log_level = log_level , simple_tui = simple_tui , loop = loop , restrict = restrict , print_errors = print_errors , sponsor_block = sponsor_block , ) download ( song ) \u00a4 Download and convert song to the output format. Arguments \u00a4 song: Song object Returns \u00a4 A tuple containing the song and the path to the downloaded file if successful. Source code in spotdl/__init__.py 189 190 191 192 193 194 195 196 197 198 199 200 def download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song ) download_songs ( songs ) \u00a4 Download and convert songs to the output format. Arguments \u00a4 songs: List of Song objects Returns \u00a4 A list of tuples containing the song and the path to the downloaded file if successful. Source code in spotdl/__init__.py 202 203 204 205 206 207 208 209 210 211 212 213 def download_songs ( self , songs : List [ Song ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs ) get_download_urls ( songs ) \u00a4 Get the download urls for a list of songs. Arguments \u00a4 songs: List of Song objects Returns \u00a4 A list of urls if successful. Notes \u00a4 This function is multi-threaded. Source code in spotdl/__init__.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_download_urls ( self , songs : List [ Song ]) -> List [ Optional [ str ]]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional [ str ]] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) return urls search ( query ) \u00a4 Search for songs. Arguments \u00a4 query: List of search queries Returns \u00a4 A list of Song objects Notes \u00a4 query can be a list of song titles, urls, uris Source code in spotdl/__init__.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def search ( self , query : List [ str ]) -> List [ Song ]: \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads )","title":"__init__"},{"location":"reference/#spotdl.Spotdl","text":"Spotdl class, which simplifies the process of downloading songs from Spotify. from spotdl import Spotdl spotdl = Spotdl ( client_id = 'your-client-id' , client_secret = 'your-client-secret' ) songs = spotdl . search ([ 'joji - test drive' , 'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT' ]) results = spotdl . download_songs ( songs ) song , path = spotd . download ( songs [ 0 ])","title":"Spotdl"},{"location":"reference/#spotdl.Spotdl--arguments","text":"client_id: Spotify client id client_secret: Spotify client secret user_auth: If true, user will be prompted to authenticate cache_path: Path to cache directory no_cache: If true, no cache will be used headless: If true, no browser will be opened audio_providers: The audio providers to use. lyrics_providers: The lyrics providers to use. ffmpeg: The ffmpeg executable to use. variable_bitrate: The variable bitrate to use. constant_bitrate: The constant bitrate to use. ffmpeg_args: The ffmpeg arguments to use. output_format: The output format to use. threads: The number of threads to use. output: The output directory to use. save_file: The save file to use when saving/loading song metadata. overwrite: The overwrite mode to use (force/skip). cookie_file: The cookie file to use for yt-dlp. filter_results: Whether to filter results. search_query: The search query to use. log_level: The log level to use. simple_tui: Whether to use simple tui. loop: The event loop to use. restrict: Whether to restrict the filename to ASCII characters. print_errors: Whether to print errors on exit. sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor.","title":"Arguments"},{"location":"reference/#spotdl.Spotdl--notes","text":"search-query uses the same format as output . Source code in spotdl/__init__.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def __init__ ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : Optional [ str ] = None , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Spotdl class ### Arguments - client_id: Spotify client id - client_secret: Spotify client secret - user_auth: If true, user will be prompted to authenticate - cache_path: Path to cache directory - no_cache: If true, no cache will be used - headless: If true, no browser will be opened - audio_providers: The audio providers to use. - lyrics_providers: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] # Initialize spotify client SpotifyClient . init ( client_id = client_id , client_secret = client_secret , user_auth = user_auth , cache_path = cache_path , no_cache = no_cache , open_browser = not headless , ) # Initialize downloader self . downloader = Downloader ( audio_providers = audio_providers , lyrics_providers = lyrics_providers , search_query = search_query , ffmpeg = ffmpeg , bitrate = bitrate , ffmpeg_args = ffmpeg_args , output_format = output_format , threads = threads , output = output , save_file = save_file , overwrite = overwrite , cookie_file = cookie_file , filter_results = filter_results , log_level = log_level , simple_tui = simple_tui , loop = loop , restrict = restrict , print_errors = print_errors , sponsor_block = sponsor_block , )","title":"Notes"},{"location":"reference/#spotdl.Spotdl.download","text":"Download and convert song to the output format.","title":"download()"},{"location":"reference/#spotdl.Spotdl.download--arguments","text":"song: Song object","title":"Arguments"},{"location":"reference/#spotdl.Spotdl.download--returns","text":"A tuple containing the song and the path to the downloaded file if successful. Source code in spotdl/__init__.py 189 190 191 192 193 194 195 196 197 198 199 200 def download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song )","title":"Returns"},{"location":"reference/#spotdl.Spotdl.download_songs","text":"Download and convert songs to the output format.","title":"download_songs()"},{"location":"reference/#spotdl.Spotdl.download_songs--arguments","text":"songs: List of Song objects","title":"Arguments"},{"location":"reference/#spotdl.Spotdl.download_songs--returns","text":"A list of tuples containing the song and the path to the downloaded file if successful. Source code in spotdl/__init__.py 202 203 204 205 206 207 208 209 210 211 212 213 def download_songs ( self , songs : List [ Song ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs )","title":"Returns"},{"location":"reference/#spotdl.Spotdl.get_download_urls","text":"Get the download urls for a list of songs.","title":"get_download_urls()"},{"location":"reference/#spotdl.Spotdl.get_download_urls--arguments","text":"songs: List of Song objects","title":"Arguments"},{"location":"reference/#spotdl.Spotdl.get_download_urls--returns","text":"A list of urls if successful.","title":"Returns"},{"location":"reference/#spotdl.Spotdl.get_download_urls--notes","text":"This function is multi-threaded. Source code in spotdl/__init__.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_download_urls ( self , songs : List [ Song ]) -> List [ Optional [ str ]]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional [ str ]] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) return urls","title":"Notes"},{"location":"reference/#spotdl.Spotdl.search","text":"Search for songs.","title":"search()"},{"location":"reference/#spotdl.Spotdl.search--arguments","text":"query: List of search queries","title":"Arguments"},{"location":"reference/#spotdl.Spotdl.search--returns","text":"A list of Song objects","title":"Returns"},{"location":"reference/#spotdl.Spotdl.search--notes","text":"query can be a list of song titles, urls, uris Source code in spotdl/__init__.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def search ( self , query : List [ str ]) -> List [ Song ]: \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads )","title":"Notes"},{"location":"reference/SUMMARY/","text":"__init__ types song artist saved album playlist console sync web save download entry_point utils metadata formatter m3u config arguments github spotify search ffmpeg providers lyrics genius musixmatch base azlyrics audio ytmusic youtube base download downloader progress_handler","title":"SUMMARY"},{"location":"reference/console/","text":"Console module, contains the console entry point and different subcommands.","title":"console"},{"location":"reference/console/download/","text":"Download module for the console. download ( query , downloader , save_path = None , m3u_file = None , ** _ ) \u00a4 Find songs with the provided audio provider and save them to the disk. Arguments \u00a4 query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to or None. m3u_file: Path to the m3u file to save the songs to. Source code in spotdl/console/download.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def download ( query : List [ str ], downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ** _ ) -> None : \"\"\" Find songs with the provided audio provider and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to or None. - m3u_file: Path to the m3u file to save the songs to. \"\"\" # Parse the query songs = get_simple_songs ( query ) results = downloader . download_multiple_songs ( songs ) if m3u_file : song_list = [ song for song , _ in results ] create_m3u_file ( m3u_file , song_list , downloader . output , downloader . output_format , False ) if save_path : # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( [ song . json for song in songs ], save_file , indent = 4 , ensure_ascii = False )","title":"download"},{"location":"reference/console/download/#spotdl.console.download.download","text":"Find songs with the provided audio provider and save them to the disk.","title":"download()"},{"location":"reference/console/download/#spotdl.console.download.download--arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to or None. m3u_file: Path to the m3u file to save the songs to. Source code in spotdl/console/download.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def download ( query : List [ str ], downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ** _ ) -> None : \"\"\" Find songs with the provided audio provider and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to or None. - m3u_file: Path to the m3u file to save the songs to. \"\"\" # Parse the query songs = get_simple_songs ( query ) results = downloader . download_multiple_songs ( songs ) if m3u_file : song_list = [ song for song , _ in results ] create_m3u_file ( m3u_file , song_list , downloader . output , downloader . output_format , False ) if save_path : # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( [ song . json for song in songs ], save_file , indent = 4 , ensure_ascii = False )","title":"Arguments"},{"location":"reference/console/entry_point/","text":"Module that holds the entry point for the console. console_entry_point () \u00a4 Wrapper around entry_point so we can profile the code Source code in spotdl/console/entry_point.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def console_entry_point (): \"\"\" Wrapper around `entry_point` so we can profile the code \"\"\" if \"--profile\" in sys . argv : with cProfile . Profile () as profile : entry_point () stats = pstats . Stats ( profile ) stats . sort_stats ( pstats . SortKey . TIME ) # Use snakeviz to visualize the profile stats . dump_stats ( \"spotdl.profile\" ) else : entry_point () entry_point () \u00a4 Console entry point for spotdl. This is where the magic happens. Source code in spotdl/console/entry_point.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def entry_point (): \"\"\" Console entry point for spotdl. This is where the magic happens. \"\"\" # Don't log too much logging . getLogger ( \"requests\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"urllib3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"spotipy\" ) . setLevel ( logging . NOTSET ) # logging.getLogger(\"asyncio\").setLevel(logging.WARNING) # Create a console console = Console () # Install rich traceback handler install ( show_locals = False , extra_lines = 1 ) # Create config file if it doesn't exist if get_config_file () . is_file () is False : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) if getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 : # If the application is frozen, we check for ffmpeg # if it's not present download it create config file if is_ffmpeg_installed () is False : download_ffmpeg () try : get_config () except ConfigError : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) # Download ffmpeg if the `--download-ffmpeg` flag is passed # This is done before the argument parser so it doesn't require `operation` # and `query` to be passed. Exit after downloading ffmpeg if \"--download-ffmpeg\" in sys . argv : if get_local_ffmpeg () is not None or is_ffmpeg_installed (): overwrite_ffmpeg = input ( \"FFmpeg is already installed. Do you want to overwrite it? (y/N): \" ) if overwrite_ffmpeg . lower () == \"y\" : local_ffmpeg = download_ffmpeg () if local_ffmpeg . is_file (): print ( f \"FFmpeg successfully downloaded to { local_ffmpeg . absolute () } \" ) else : print ( \"FFmpeg download failed\" ) else : print ( \"Downloading FFmpeg...\" ) download_path = download_ffmpeg () if download_path . is_file (): print ( f \"FFmpeg successfully downloaded to { download_path . absolute () } \" ) else : print ( \"FFmpeg download failed\" ) return None # Generate the config file if it doesn't exist # or overwrite the current config file if the `--overwrite-config` flag is passed # This is done before the argument parser so it doesn't requires `operation` # and `query` to be passed. exit after downloading ffmpeg if \"--generate-config\" in sys . argv : config_path = get_config_file () if config_path . exists (): overwrite_config = input ( \"Config file already exists. Overwrite? (y/N): \" ) if overwrite_config . lower () != \"y\" : print ( \"Exiting...\" ) return None with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) print ( f \"Config file generated at { config_path } \" ) return None # Get information about the current version and display it # Exit after displaying the version if \"--check-for-updates\" in sys . argv : check_for_updates () return None # Parse the arguments arguments = parse_arguments () # Get the config file # It will automatically load if the `load_config` is set to True # in the config file config = {} if arguments . config or ( get_config_file () . exists () and get_config () . get ( \"load_config\" ) ): config = get_config () # Create settings dict # Argument value has always the priority, then the config file # value, and if neither are set, use default value settings = {} for key , default_value in DEFAULT_CONFIG . items (): argument_val = arguments . __dict__ . get ( key ) config_val = config . get ( key ) if argument_val is not None : settings [ key ] = argument_val elif config_val is not None : settings [ key ] = config_val else : settings [ key ] = default_value # Check if ffmpeg is installed if is_ffmpeg_installed ( settings [ \"ffmpeg\" ]) is False : raise FFmpegError ( \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \" \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\" ) if \"youtube-music\" in settings [ \"audio_providers\" ]: # Check if we are getting results from YouTube Music ytm = YouTubeMusic ( settings ) test_results = ytm . get_results ( \"a\" ) if len ( test_results ) == 0 : raise AudioProviderError ( \"Could not connect to YouTube Music API. Use a VPN or other audio provider.\" ) # Initialize spotify client SpotifyClient . init ( client_id = settings [ \"client_id\" ], client_secret = settings [ \"client_secret\" ], auth_token = settings [ \"auth_token\" ], user_auth = settings [ \"user_auth\" ], cache_path = settings [ \"cache_path\" ], no_cache = settings [ \"no_cache\" ], open_browser = not settings [ \"headless\" ], ) # If the application is frozen start web ui # or if the operation is `web` if ( getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 or arguments . operation == \"web\" ): from spotdl.console.web import ( # pylint: disable=C0415,C0410,W0707,W0611 web , ) # Don't log too much when running web ui & default logging argument if arguments . __dict__ . get ( \"log_level\" ) is None : settings [ \"log_level\" ] = \"CRITICAL\" # Start web ui web ( settings ) return None # Check if save file is present and if it's valid if isinstance ( settings [ \"save_file\" ], str ) and not settings [ \"save_file\" ] . endswith ( \".spotdl\" ): raise DownloaderError ( \"Save file has to end with .spotdl\" ) if arguments . query and \"saved\" in arguments . query and not settings [ \"user_auth\" ]: raise SpotifyError ( \"You must be logged in to use the saved query. \\ Log in by adding the --user-auth flag\" ) # Initialize the downloader # for download, load and preload operations downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], search_query = settings [ \"search_query\" ], cookie_file = settings [ \"cookie_file\" ], log_level = settings [ \"log_level\" ], simple_tui = settings [ \"simple_tui\" ], restrict = settings [ \"restrict\" ], print_errors = settings [ \"print_errors\" ], sponsor_block = settings [ \"sponsor_block\" ], ) def graceful_exit ( _signal , _frame ): downloader . progress_handler . close () sys . exit ( 0 ) signal . signal ( signal . SIGINT , graceful_exit ) signal . signal ( signal . SIGTERM , graceful_exit ) try : # Pick the operation to perform # based on the name and run it! OPERATIONS [ arguments . operation ]( query = arguments . query , save_path = settings [ \"save_file\" ], preload = settings [ \"preload\" ], downloader = downloader , m3u_file = settings [ \"m3u\" ], ) except Exception : downloader . progress_handler . close () console . print_exception ( show_locals = False , extra_lines = 1 ) sys . exit ( 1 ) downloader . progress_handler . close () return None","title":"entry_point"},{"location":"reference/console/entry_point/#spotdl.console.entry_point.console_entry_point","text":"Wrapper around entry_point so we can profile the code Source code in spotdl/console/entry_point.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def console_entry_point (): \"\"\" Wrapper around `entry_point` so we can profile the code \"\"\" if \"--profile\" in sys . argv : with cProfile . Profile () as profile : entry_point () stats = pstats . Stats ( profile ) stats . sort_stats ( pstats . SortKey . TIME ) # Use snakeviz to visualize the profile stats . dump_stats ( \"spotdl.profile\" ) else : entry_point ()","title":"console_entry_point()"},{"location":"reference/console/entry_point/#spotdl.console.entry_point.entry_point","text":"Console entry point for spotdl. This is where the magic happens. Source code in spotdl/console/entry_point.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def entry_point (): \"\"\" Console entry point for spotdl. This is where the magic happens. \"\"\" # Don't log too much logging . getLogger ( \"requests\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"urllib3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"spotipy\" ) . setLevel ( logging . NOTSET ) # logging.getLogger(\"asyncio\").setLevel(logging.WARNING) # Create a console console = Console () # Install rich traceback handler install ( show_locals = False , extra_lines = 1 ) # Create config file if it doesn't exist if get_config_file () . is_file () is False : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) if getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 : # If the application is frozen, we check for ffmpeg # if it's not present download it create config file if is_ffmpeg_installed () is False : download_ffmpeg () try : get_config () except ConfigError : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) # Download ffmpeg if the `--download-ffmpeg` flag is passed # This is done before the argument parser so it doesn't require `operation` # and `query` to be passed. Exit after downloading ffmpeg if \"--download-ffmpeg\" in sys . argv : if get_local_ffmpeg () is not None or is_ffmpeg_installed (): overwrite_ffmpeg = input ( \"FFmpeg is already installed. Do you want to overwrite it? (y/N): \" ) if overwrite_ffmpeg . lower () == \"y\" : local_ffmpeg = download_ffmpeg () if local_ffmpeg . is_file (): print ( f \"FFmpeg successfully downloaded to { local_ffmpeg . absolute () } \" ) else : print ( \"FFmpeg download failed\" ) else : print ( \"Downloading FFmpeg...\" ) download_path = download_ffmpeg () if download_path . is_file (): print ( f \"FFmpeg successfully downloaded to { download_path . absolute () } \" ) else : print ( \"FFmpeg download failed\" ) return None # Generate the config file if it doesn't exist # or overwrite the current config file if the `--overwrite-config` flag is passed # This is done before the argument parser so it doesn't requires `operation` # and `query` to be passed. exit after downloading ffmpeg if \"--generate-config\" in sys . argv : config_path = get_config_file () if config_path . exists (): overwrite_config = input ( \"Config file already exists. Overwrite? (y/N): \" ) if overwrite_config . lower () != \"y\" : print ( \"Exiting...\" ) return None with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) print ( f \"Config file generated at { config_path } \" ) return None # Get information about the current version and display it # Exit after displaying the version if \"--check-for-updates\" in sys . argv : check_for_updates () return None # Parse the arguments arguments = parse_arguments () # Get the config file # It will automatically load if the `load_config` is set to True # in the config file config = {} if arguments . config or ( get_config_file () . exists () and get_config () . get ( \"load_config\" ) ): config = get_config () # Create settings dict # Argument value has always the priority, then the config file # value, and if neither are set, use default value settings = {} for key , default_value in DEFAULT_CONFIG . items (): argument_val = arguments . __dict__ . get ( key ) config_val = config . get ( key ) if argument_val is not None : settings [ key ] = argument_val elif config_val is not None : settings [ key ] = config_val else : settings [ key ] = default_value # Check if ffmpeg is installed if is_ffmpeg_installed ( settings [ \"ffmpeg\" ]) is False : raise FFmpegError ( \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \" \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\" ) if \"youtube-music\" in settings [ \"audio_providers\" ]: # Check if we are getting results from YouTube Music ytm = YouTubeMusic ( settings ) test_results = ytm . get_results ( \"a\" ) if len ( test_results ) == 0 : raise AudioProviderError ( \"Could not connect to YouTube Music API. Use a VPN or other audio provider.\" ) # Initialize spotify client SpotifyClient . init ( client_id = settings [ \"client_id\" ], client_secret = settings [ \"client_secret\" ], auth_token = settings [ \"auth_token\" ], user_auth = settings [ \"user_auth\" ], cache_path = settings [ \"cache_path\" ], no_cache = settings [ \"no_cache\" ], open_browser = not settings [ \"headless\" ], ) # If the application is frozen start web ui # or if the operation is `web` if ( getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 or arguments . operation == \"web\" ): from spotdl.console.web import ( # pylint: disable=C0415,C0410,W0707,W0611 web , ) # Don't log too much when running web ui & default logging argument if arguments . __dict__ . get ( \"log_level\" ) is None : settings [ \"log_level\" ] = \"CRITICAL\" # Start web ui web ( settings ) return None # Check if save file is present and if it's valid if isinstance ( settings [ \"save_file\" ], str ) and not settings [ \"save_file\" ] . endswith ( \".spotdl\" ): raise DownloaderError ( \"Save file has to end with .spotdl\" ) if arguments . query and \"saved\" in arguments . query and not settings [ \"user_auth\" ]: raise SpotifyError ( \"You must be logged in to use the saved query. \\ Log in by adding the --user-auth flag\" ) # Initialize the downloader # for download, load and preload operations downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], search_query = settings [ \"search_query\" ], cookie_file = settings [ \"cookie_file\" ], log_level = settings [ \"log_level\" ], simple_tui = settings [ \"simple_tui\" ], restrict = settings [ \"restrict\" ], print_errors = settings [ \"print_errors\" ], sponsor_block = settings [ \"sponsor_block\" ], ) def graceful_exit ( _signal , _frame ): downloader . progress_handler . close () sys . exit ( 0 ) signal . signal ( signal . SIGINT , graceful_exit ) signal . signal ( signal . SIGTERM , graceful_exit ) try : # Pick the operation to perform # based on the name and run it! OPERATIONS [ arguments . operation ]( query = arguments . query , save_path = settings [ \"save_file\" ], preload = settings [ \"preload\" ], downloader = downloader , m3u_file = settings [ \"m3u\" ], ) except Exception : downloader . progress_handler . close () console . print_exception ( show_locals = False , extra_lines = 1 ) sys . exit ( 1 ) downloader . progress_handler . close () return None","title":"entry_point()"},{"location":"reference/console/save/","text":"Save module for the console. save ( query , downloader , save_path , m3u_file = None , preload = False ) \u00a4 Save metadata from spotify to the disk. Arguments \u00a4 query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the m3u file to save the songs to. preload: If True, preload the songs. Notes \u00a4 This function is multi-threaded. Source code in spotdl/console/save.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def save ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , preload : bool = False , ) -> None : \"\"\" Save metadata from spotify to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the m3u file to save the songs to. - preload: If True, preload the songs. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) save_data = [ song . json for song in songs ] if preload : save_data = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = downloader . threads ) as executor : future_to_song = { executor . submit ( downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () if data is None : downloader . progress_handler . error ( f \"Could not find a match for { song . display_name } \" ) continue downloader . progress_handler . log ( f \"Found url for { song . display_name } : { data } \" ) save_data . append ({ ** song . json , \"download_url\" : data }) except Exception as exc : downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved { len ( save_data ) } song { 's' if len ( save_data ) > 1 else '' } to { save_path } \" )","title":"save"},{"location":"reference/console/save/#spotdl.console.save.save","text":"Save metadata from spotify to the disk.","title":"save()"},{"location":"reference/console/save/#spotdl.console.save.save--arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the m3u file to save the songs to. preload: If True, preload the songs.","title":"Arguments"},{"location":"reference/console/save/#spotdl.console.save.save--notes","text":"This function is multi-threaded. Source code in spotdl/console/save.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def save ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , preload : bool = False , ) -> None : \"\"\" Save metadata from spotify to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the m3u file to save the songs to. - preload: If True, preload the songs. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) save_data = [ song . json for song in songs ] if preload : save_data = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = downloader . threads ) as executor : future_to_song = { executor . submit ( downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () if data is None : downloader . progress_handler . error ( f \"Could not find a match for { song . display_name } \" ) continue downloader . progress_handler . log ( f \"Found url for { song . display_name } : { data } \" ) save_data . append ({ ** song . json , \"download_url\" : data }) except Exception as exc : downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved { len ( save_data ) } song { 's' if len ( save_data ) > 1 else '' } to { save_path } \" )","title":"Notes"},{"location":"reference/console/sync/","text":"Sync module for the console. sync ( query , downloader , save_path = None , m3u_file = None , ** _ ) \u00a4 Sync function for the console. It will download the songs and remove the ones that are no longer present in the playlists/albums/etc Arguments \u00a4 query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the file to save the metadata to. Source code in spotdl/console/sync.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def sync ( query : List [ str ], downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ** _ , ) -> None : \"\"\" Sync function for the console. It will download the songs and remove the ones that are no longer present in the playlists/albums/etc ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the file to save the metadata to. \"\"\" downloader . save_file = None # Query and save file # Create initial sync file if query and save_path : if any ( req for req in query if req . endswith ( \".spotdl\" )): # If the query contains a .spotdl file, and we are about to create # .spotdl file, raise an error. raise ValueError ( \"Cannot create a sync file with a .spotdl file in the query.\" ) # Parse the query songs_list = parse_query ( query , downloader . threads ) # Create sync file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( { \"type\" : \"sync\" , \"query\" : query , \"songs\" : [ song . json for song in songs_list ], }, save_file , indent = 4 , ensure_ascii = False , ) # Perform initial download downloader . download_multiple_songs ( songs_list ) if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False ) return None # If the query is a single file, download it if len ( query ) == 1 and query [ 0 ] . endswith ( \".spotdl\" ) and not save_path : # Load the sync file with open ( query [ 0 ], \"r\" , encoding = \"utf-8\" ) as sync_file : sync_data = json . load ( sync_file ) # Verify the sync file if sync_data . get ( \"type\" ) != \"sync\" : raise ValueError ( \"Sync file is not a valid sync file.\" ) # Parse the query songs_list = parse_query ( sync_data [ \"query\" ], downloader . threads ) # Get all the old files based on the songs from sync file old_files = [ create_file_name ( Song ( ** song ), downloader . output , downloader . output_format ) for song in sync_data [ \"songs\" ] ] # Get all output file names new_files = [ create_file_name ( song , downloader . output , downloader . output_format ) for song in songs_list ] # Get all files that are no longer in the song lists to_delete = set ( old_files ) - set ( new_files ) # Delete all files that are no longer in the song lists for file in to_delete : if file . exists (): downloader . progress_handler . log ( f \"Deleting { file } \" ) file . unlink () else : downloader . progress_handler . debug ( f \" { file } does not exist.\" ) to_download = [] for song in songs_list : song_path = create_file_name ( song , downloader . output , downloader . output_format ) if Path ( song_path ) . exists (): if downloader . overwrite == \"force\" : downloader . progress_handler . log ( f \"Overwriting { song . display_name } \" ) to_download . append ( song ) else : to_download . append ( song ) if len ( to_download ) == 0 : downloader . progress_handler . log ( \"Nothing to do...\" ) return None if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False , ) with open ( query [ 0 ], \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( { \"type\" : \"sync\" , \"query\" : sync_data [ \"query\" ], \"songs\" : [ song . json for song in songs_list ], }, save_file , indent = 4 , ensure_ascii = False , ) downloader . download_multiple_songs ( to_download ) return None raise ValueError ( \"Wrong combination of arguments. \" \"Either provide a query and a save path. Or a single sync file in the query\" )","title":"sync"},{"location":"reference/console/sync/#spotdl.console.sync.sync","text":"Sync function for the console. It will download the songs and remove the ones that are no longer present in the playlists/albums/etc","title":"sync()"},{"location":"reference/console/sync/#spotdl.console.sync.sync--arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the file to save the metadata to. Source code in spotdl/console/sync.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def sync ( query : List [ str ], downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ** _ , ) -> None : \"\"\" Sync function for the console. It will download the songs and remove the ones that are no longer present in the playlists/albums/etc ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the file to save the metadata to. \"\"\" downloader . save_file = None # Query and save file # Create initial sync file if query and save_path : if any ( req for req in query if req . endswith ( \".spotdl\" )): # If the query contains a .spotdl file, and we are about to create # .spotdl file, raise an error. raise ValueError ( \"Cannot create a sync file with a .spotdl file in the query.\" ) # Parse the query songs_list = parse_query ( query , downloader . threads ) # Create sync file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( { \"type\" : \"sync\" , \"query\" : query , \"songs\" : [ song . json for song in songs_list ], }, save_file , indent = 4 , ensure_ascii = False , ) # Perform initial download downloader . download_multiple_songs ( songs_list ) if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False ) return None # If the query is a single file, download it if len ( query ) == 1 and query [ 0 ] . endswith ( \".spotdl\" ) and not save_path : # Load the sync file with open ( query [ 0 ], \"r\" , encoding = \"utf-8\" ) as sync_file : sync_data = json . load ( sync_file ) # Verify the sync file if sync_data . get ( \"type\" ) != \"sync\" : raise ValueError ( \"Sync file is not a valid sync file.\" ) # Parse the query songs_list = parse_query ( sync_data [ \"query\" ], downloader . threads ) # Get all the old files based on the songs from sync file old_files = [ create_file_name ( Song ( ** song ), downloader . output , downloader . output_format ) for song in sync_data [ \"songs\" ] ] # Get all output file names new_files = [ create_file_name ( song , downloader . output , downloader . output_format ) for song in songs_list ] # Get all files that are no longer in the song lists to_delete = set ( old_files ) - set ( new_files ) # Delete all files that are no longer in the song lists for file in to_delete : if file . exists (): downloader . progress_handler . log ( f \"Deleting { file } \" ) file . unlink () else : downloader . progress_handler . debug ( f \" { file } does not exist.\" ) to_download = [] for song in songs_list : song_path = create_file_name ( song , downloader . output , downloader . output_format ) if Path ( song_path ) . exists (): if downloader . overwrite == \"force\" : downloader . progress_handler . log ( f \"Overwriting { song . display_name } \" ) to_download . append ( song ) else : to_download . append ( song ) if len ( to_download ) == 0 : downloader . progress_handler . log ( \"Nothing to do...\" ) return None if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False , ) with open ( query [ 0 ], \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( { \"type\" : \"sync\" , \"query\" : sync_data [ \"query\" ], \"songs\" : [ song . json for song in songs_list ], }, save_file , indent = 4 , ensure_ascii = False , ) downloader . download_multiple_songs ( to_download ) return None raise ValueError ( \"Wrong combination of arguments. \" \"Either provide a query and a save path. Or a single sync file in the query\" )","title":"Arguments"},{"location":"reference/console/web/","text":"Web module for the console. App \u00a4 App class that holds the application state. SPAStaticFiles \u00a4 Bases: StaticFiles Override the static files to serve the index.html and other assets. get_response ( path , scope ) async \u00a4 Serve static files from the SPA. Arguments \u00a4 path: The path to the file. scope: The scope of the request. Returns \u00a4 returns the response. Source code in spotdl/console/web.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 async def get_response ( self , path : str , scope : Scope ) -> Response : \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super () . get_response ( path , scope ) if response . status_code == 404 : response = await super () . get_response ( \".\" , scope ) return response SettingsModel \u00a4 Bases: BaseModel A settings object used for types and validation. SongModel \u00a4 Bases: BaseModel A song object used for types and validation. We can't use the Song class directly because FastAPI doesn't support dataclasses. WSProgressHandler ( websocket , client_id ) \u00a4 Handles all the WebSocket connections. Arguments \u00a4 websocket: The WebSocket instance. client_id: The client's ID. Source code in spotdl/console/web.py 129 130 131 132 133 134 135 136 137 138 139 def __init__ ( self , websocket : WebSocket , client_id : str ): \"\"\" Initialize the WebSocket handler. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" self . client_id = client_id self . websocket = websocket connect () async \u00a4 Called when a new client connects to the websocket. Source code in spotdl/console/web.py 141 142 143 144 145 146 147 148 149 async def connect ( self ): \"\"\" Called when a new client connects to the websocket. \"\"\" connection = { \"client_id\" : self . client_id , \"websocket\" : self . websocket } logging . info ( \"Connecting WebSocket: %s \" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self ) get ( client_id ) classmethod \u00a4 Get a WSProgressHandler instance by client_id. Arguments \u00a4 client_id: The client's ID. Source code in spotdl/console/web.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @classmethod def get ( cls , client_id : str ): \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None send_update ( message ) async \u00a4 Send an update to the client. Arguments \u00a4 message: The message to send. Source code in spotdl/console/web.py 171 172 173 174 175 176 177 178 179 180 async def send_update ( self , message : str ): \"\"\" Send an update to the client. ### Arguments - message: The message to send. \"\"\" logging . debug ( \"Sending %s : %s \" , self . client_id , message ) await self . websocket . send_text ( message ) update ( progress_handler_instance , message ) \u00a4 Callback function from ProgressHandler's SongTracker, called on every update Arguments \u00a4 progress_handler_instance: The ProgressHandler instance. message: The message to send. Source code in spotdl/console/web.py 182 183 184 185 186 187 188 189 190 191 192 193 194 def update ( self , progress_handler_instance : SongTracker , message : str ): \"\"\"Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance: The ProgressHandler instance. - message: The message to send. \"\"\" update_message = { \"song\" : progress_handler_instance . song . json , \"progress\" : progress_handler_instance . progress , \"message\" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message ))) change_output ( output ) \u00a4 Change output folder Arguments \u00a4 output: The output folder. Returns \u00a4 returns True if the output folder was changed. Source code in spotdl/console/web.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 @app . server . post ( \"/api/downloader/change_output\" ) def change_output ( output : str ) -> bool : \"\"\" Change output folder ### Arguments - output: The output folder. ### Returns - returns True if the output folder was changed. \"\"\" app . downloader . output = output return True change_settings ( settings ) \u00a4 Change downloader settings by re-initializing the downloader. Arguments \u00a4 settings: The settings to change. Returns \u00a4 returns True if the settings were changed. Source code in spotdl/console/web.py 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 @app . server . post ( \"/api/settings/update\" ) def change_settings ( settings : SettingsModel ) -> bool : \"\"\" Change downloader settings by re-initializing the downloader. ### Arguments - settings: The settings to change. ### Returns - returns True if the settings were changed. \"\"\" settings_dict = settings . dict () # Create shallow copy of settings settings_cpy = app . settings . copy () # Update settings with new settings that are not None settings_cpy . update ({ k : v for k , v in settings_dict . items () if v is not None }) logging . debug ( \"Applying settings: %s \" , { settings_cpy }) # Re-initialize downloader app . downloader = Downloader ( audio_providers = settings_cpy [ \"audio_providers\" ], lyrics_providers = settings_cpy [ \"lyrics_providers\" ], ffmpeg = settings_cpy [ \"ffmpeg\" ], bitrate = settings_cpy [ \"bitrate\" ], ffmpeg_args = settings_cpy [ \"ffmpeg_args\" ], output_format = settings_cpy [ \"format\" ], save_file = settings_cpy [ \"save_file\" ], threads = settings_cpy [ \"threads\" ], output = settings_cpy [ \"output\" ], overwrite = settings_cpy [ \"overwrite\" ], log_level = \"CRITICAL\" , simple_tui = True , loop = app . loop , ) return True download_file ( file , client_id ) async \u00a4 Download file using path. Arguments \u00a4 file: The file path. client_id: The client's ID. Returns \u00a4 returns the file response, filename specified to return as attachment. Source code in spotdl/console/web.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 @app . server . get ( \"/api/download/file\" ) async def download_file ( file : str , client_id : str ) -> FileResponse : \"\"\" Download file using path. ### Arguments - file: The file path. - client_id: The client's ID. ### Returns - returns the file response, filename specified to return as attachment. \"\"\" return FileResponse ( str (( get_spotdl_path () / f \"web/sessions/ { client_id } / { file } \" ) . absolute ()), filename = file , ) download_multiple_objects ( songs ) \u00a4 Download songs using Song objects. Arguments \u00a4 songs: The list of Song objects. Returns \u00a4 returns a list of Tuple of Song and Path if the song was downloaded. Source code in spotdl/console/web.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 @app . server . post ( \"/api/download/multiple_objects\" ) def download_multiple_objects ( songs : List [ SongModel ], ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download songs using Song objects. ### Arguments - songs: The list of Song objects. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( [ Song . from_dict ( song . dict ()) for song in songs ] ) download_multiple_search ( query ) \u00a4 Search for song and download the first result. Arguments \u00a4 query: The query to search. Returns \u00a4 returns a list of Tuple of Song and Path if the song was downloaded. Source code in spotdl/console/web.py 440 441 442 443 444 445 446 447 448 449 450 451 452 @app . server . post ( \"/api/download/multiple_search\" ) def download_multiple_search ( query : List [ str ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( parse_query ( query )) download_objects ( song , return_file = False ) async \u00a4 Download songs using Song objects. Arguments \u00a4 song: The Song object. return_file: If True, return the file instead of the song. Returns \u00a4 returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. Source code in spotdl/console/web.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 @app . server . post ( \"/api/download/objects\" ) async def download_objects ( song : SongModel , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Download songs using Song objects. ### Arguments - song: The Song object. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song_obj , path = await app . downloader . pool_download ( Song ( ** song . dict ())) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song_obj , path download_search ( query , return_file = False ) async \u00a4 Search for song and download the first result. Arguments \u00a4 query: The query to search. return_file: If True, return the file instead of the song. Returns \u00a4 returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. Source code in spotdl/console/web.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 @app . server . post ( \"/api/downloader/download/search\" ) async def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song , path = await app . downloader . pool_download ( Song . from_search_term ( query )) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song , path download_url ( url , client_id ) async \u00a4 Download songs using Song url. Arguments \u00a4 url: The url to download. client_id: The client's ID. Returns \u00a4 returns the file path if the song was downloaded. Source code in spotdl/console/web.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 @app . server . post ( \"/api/download/url\" ) async def download_url ( url : str , client_id : str ) -> Optional [ str ]: \"\"\" Download songs using Song url. ### Arguments - url: The url to download. - client_id: The client's ID. ### Returns - returns the file path if the song was downloaded. \"\"\" app . downloader . output = str ( ( get_spotdl_path () / f \"web/sessions/ { client_id } \" ) . absolute () ) # Initiate realtime updates if websocket from client is connected ws_instance = WSProgressHandler . get ( client_id ) if ws_instance is not None : app . downloader . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ app . settings [ \"log_level\" ]], simple_tui = True , update_callback = ws_instance . update , ) try : # Fetch song metadata song = Song . from_url ( url ) # Download Song _ , path = await app . downloader . pool_download ( song ) if path is None : exc = DownloaderError ( f \"Failure downloading { song . name } \" ) logging . warning ( \"Error downloading! %s \" , exc ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exc } \" ) # Strip Filename filename = os . path . basename ( path ) return filename except Exception as exception : logging . warning ( \"Error downloading! %s \" , exception ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exception } \" ) from exception fix_mime_types () \u00a4 Fix incorrect entries in the mimetypes registry. On Windows, the Python standard library's mimetypes reads in mappings from file extension to MIME type from the Windows registry. Other applications can and do write incorrect values to this registry, which causes mimetypes.guess_type to return incorrect values, which causes spotDL to fail to render on the frontend. This method hard-codes the correct mappings for certain MIME types that are known to be either used by TensorBoard or problematic in general. Source code in spotdl/console/web.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def fix_mime_types (): \"\"\"Fix incorrect entries in the `mimetypes` registry. On Windows, the Python standard library's `mimetypes` reads in mappings from file extension to MIME type from the Windows registry. Other applications can and do write incorrect values to this registry, which causes `mimetypes.guess_type` to return incorrect values, which causes spotDL to fail to render on the frontend. This method hard-codes the correct mappings for certain MIME types that are known to be either used by TensorBoard or problematic in general. \"\"\" # Known to be problematic when Visual Studio is installed: # <https://github.com/tensorflow/tensorboard/issues/3120> # https://github.com/spotDL/spotify-downloader/issues/1540 mimetypes . add_type ( \"application/javascript\" , \".js\" ) # Not known to be problematic, but used by spotDL: mimetypes . add_type ( \"text/css\" , \".css\" ) mimetypes . add_type ( \"image/svg+xml\" , \".svg\" ) mimetypes . add_type ( \"text/html\" , \".html\" ) get_settings () \u00a4 Return the settings object. Returns \u00a4 returns the settings object. Source code in spotdl/console/web.py 474 475 476 477 478 479 480 481 482 483 @app . server . get ( \"/api/settings\" ) def get_settings () -> SettingsModel : \"\"\" Return the settings object. ### Returns - returns the settings object. \"\"\" return SettingsModel ( ** app . settings ) query_search ( query ) \u00a4 Parse a list of search queries. Arguments \u00a4 query: The query to parse. Returns \u00a4 returns a list of Song objects. Source code in spotdl/console/web.py 269 270 271 272 273 274 275 276 277 278 279 280 281 @app . server . post ( \"/api/songs/query\" ) def query_search ( query : List [ str ]) -> List [ Song ]: \"\"\" Parse a list of search queries. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return parse_query ( query ) search_search ( query ) \u00a4 Parse search term and return list of Song objects. Arguments \u00a4 query: The query to parse. Returns \u00a4 returns a list of Song objects. Source code in spotdl/console/web.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 @app . server . get ( \"/api/songs/search\" ) def search_search ( query : str ) -> List [ Song ]: \"\"\" Parse search term and return list of Song objects. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" # return parse_query([query], app.downloader.threads) return get_search_results ( query ) song_from_search ( query ) \u00a4 Search for a song on spotify using search query. Arguments \u00a4 query: The search query. Returns \u00a4 returns the first result as a Song object. Source code in spotdl/console/web.py 239 240 241 242 243 244 245 246 247 248 249 250 251 @app . server . get ( \"/api/song/search\" ) def song_from_search ( query : str ) -> Song : \"\"\" Search for a song on spotify using search query. ### Arguments - query: The search query. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_search_term ( query ) song_from_url ( url ) \u00a4 Search for a song on spotify using url. Arguments \u00a4 url: The url to search. Returns \u00a4 returns the first result as a Song object. Source code in spotdl/console/web.py 254 255 256 257 258 259 260 261 262 263 264 265 266 @app . server . get ( \"/api/song/url\" ) def song_from_url ( url : str ) -> Song : \"\"\" Search for a song on spotify using url. ### Arguments - url: The url to search. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_url ( url ) web ( settings ) \u00a4 Run the web server. Arguments \u00a4 settings: Settings dictionary, based on the SettingsModel class. Source code in spotdl/console/web.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def web ( settings : Dict [ str , Any ]): \"\"\" Run the web server. ### Arguments - settings: Settings dictionary, based on the `SettingsModel` class. \"\"\" fix_mime_types () web_app_dir = str ( get_spotdl_path () . absolute ()) print ( \"Updating web app\" ) # Get web client from CDN (github for now) download_github_dir ( \"https://github.com/spotdl/web-ui/tree/master/dist\" , output_dir = web_app_dir ) # Serve web client SPA app . server . mount ( \"/\" , SPAStaticFiles ( directory = web_app_dir + \"/dist\" , html = True ), name = \"static\" ) loop = asyncio . new_event_loop () app . loop = loop app . settings = settings app . downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], log_level = settings [ \"log_level\" ], simple_tui = True , loop = loop , ) config = Config ( app = app . server , port = 8800 , workers = 1 , loop = loop ) # type: ignore server = Server ( config ) webbrowser . open ( \"http://localhost:8800\" ) loop . run_until_complete ( server . serve ()) app . downloader . progress_handler . close () websocket_endpoint ( websocket , client_id ) async \u00a4 Websocket endpoint. Arguments \u00a4 websocket: The WebSocket instance. client_id: The client's ID. Source code in spotdl/console/web.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @app . server . websocket ( \"/api/ws\" ) async def websocket_endpoint ( websocket : WebSocket , client_id : str ): \"\"\" Websocket endpoint. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" await WSProgressHandler ( websocket , client_id ) . connect () try : while True : data = await websocket . receive_text () logging . debug ( \"Client %s said: %s \" , client_id , data ) except WebSocketDisconnect : logging . info ( \"Disconnecting WebSocket: %s \" , client_id )","title":"web"},{"location":"reference/console/web/#spotdl.console.web.App","text":"App class that holds the application state.","title":"App"},{"location":"reference/console/web/#spotdl.console.web.SPAStaticFiles","text":"Bases: StaticFiles Override the static files to serve the index.html and other assets.","title":"SPAStaticFiles"},{"location":"reference/console/web/#spotdl.console.web.SPAStaticFiles.get_response","text":"Serve static files from the SPA.","title":"get_response()"},{"location":"reference/console/web/#spotdl.console.web.SPAStaticFiles.get_response--arguments","text":"path: The path to the file. scope: The scope of the request.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.SPAStaticFiles.get_response--returns","text":"returns the response. Source code in spotdl/console/web.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 async def get_response ( self , path : str , scope : Scope ) -> Response : \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super () . get_response ( path , scope ) if response . status_code == 404 : response = await super () . get_response ( \".\" , scope ) return response","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.SettingsModel","text":"Bases: BaseModel A settings object used for types and validation.","title":"SettingsModel"},{"location":"reference/console/web/#spotdl.console.web.SongModel","text":"Bases: BaseModel A song object used for types and validation. We can't use the Song class directly because FastAPI doesn't support dataclasses.","title":"SongModel"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler","text":"Handles all the WebSocket connections.","title":"WSProgressHandler"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler--arguments","text":"websocket: The WebSocket instance. client_id: The client's ID. Source code in spotdl/console/web.py 129 130 131 132 133 134 135 136 137 138 139 def __init__ ( self , websocket : WebSocket , client_id : str ): \"\"\" Initialize the WebSocket handler. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" self . client_id = client_id self . websocket = websocket","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.connect","text":"Called when a new client connects to the websocket. Source code in spotdl/console/web.py 141 142 143 144 145 146 147 148 149 async def connect ( self ): \"\"\" Called when a new client connects to the websocket. \"\"\" connection = { \"client_id\" : self . client_id , \"websocket\" : self . websocket } logging . info ( \"Connecting WebSocket: %s \" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self )","title":"connect()"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.get","text":"Get a WSProgressHandler instance by client_id.","title":"get()"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.get--arguments","text":"client_id: The client's ID. Source code in spotdl/console/web.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @classmethod def get ( cls , client_id : str ): \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.send_update","text":"Send an update to the client.","title":"send_update()"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.send_update--arguments","text":"message: The message to send. Source code in spotdl/console/web.py 171 172 173 174 175 176 177 178 179 180 async def send_update ( self , message : str ): \"\"\" Send an update to the client. ### Arguments - message: The message to send. \"\"\" logging . debug ( \"Sending %s : %s \" , self . client_id , message ) await self . websocket . send_text ( message )","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.update","text":"Callback function from ProgressHandler's SongTracker, called on every update","title":"update()"},{"location":"reference/console/web/#spotdl.console.web.WSProgressHandler.update--arguments","text":"progress_handler_instance: The ProgressHandler instance. message: The message to send. Source code in spotdl/console/web.py 182 183 184 185 186 187 188 189 190 191 192 193 194 def update ( self , progress_handler_instance : SongTracker , message : str ): \"\"\"Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance: The ProgressHandler instance. - message: The message to send. \"\"\" update_message = { \"song\" : progress_handler_instance . song . json , \"progress\" : progress_handler_instance . progress , \"message\" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message )))","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.change_output","text":"Change output folder","title":"change_output()"},{"location":"reference/console/web/#spotdl.console.web.change_output--arguments","text":"output: The output folder.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.change_output--returns","text":"returns True if the output folder was changed. Source code in spotdl/console/web.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 @app . server . post ( \"/api/downloader/change_output\" ) def change_output ( output : str ) -> bool : \"\"\" Change output folder ### Arguments - output: The output folder. ### Returns - returns True if the output folder was changed. \"\"\" app . downloader . output = output return True","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.change_settings","text":"Change downloader settings by re-initializing the downloader.","title":"change_settings()"},{"location":"reference/console/web/#spotdl.console.web.change_settings--arguments","text":"settings: The settings to change.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.change_settings--returns","text":"returns True if the settings were changed. Source code in spotdl/console/web.py 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 @app . server . post ( \"/api/settings/update\" ) def change_settings ( settings : SettingsModel ) -> bool : \"\"\" Change downloader settings by re-initializing the downloader. ### Arguments - settings: The settings to change. ### Returns - returns True if the settings were changed. \"\"\" settings_dict = settings . dict () # Create shallow copy of settings settings_cpy = app . settings . copy () # Update settings with new settings that are not None settings_cpy . update ({ k : v for k , v in settings_dict . items () if v is not None }) logging . debug ( \"Applying settings: %s \" , { settings_cpy }) # Re-initialize downloader app . downloader = Downloader ( audio_providers = settings_cpy [ \"audio_providers\" ], lyrics_providers = settings_cpy [ \"lyrics_providers\" ], ffmpeg = settings_cpy [ \"ffmpeg\" ], bitrate = settings_cpy [ \"bitrate\" ], ffmpeg_args = settings_cpy [ \"ffmpeg_args\" ], output_format = settings_cpy [ \"format\" ], save_file = settings_cpy [ \"save_file\" ], threads = settings_cpy [ \"threads\" ], output = settings_cpy [ \"output\" ], overwrite = settings_cpy [ \"overwrite\" ], log_level = \"CRITICAL\" , simple_tui = True , loop = app . loop , ) return True","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.download_file","text":"Download file using path.","title":"download_file()"},{"location":"reference/console/web/#spotdl.console.web.download_file--arguments","text":"file: The file path. client_id: The client's ID.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.download_file--returns","text":"returns the file response, filename specified to return as attachment. Source code in spotdl/console/web.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 @app . server . get ( \"/api/download/file\" ) async def download_file ( file : str , client_id : str ) -> FileResponse : \"\"\" Download file using path. ### Arguments - file: The file path. - client_id: The client's ID. ### Returns - returns the file response, filename specified to return as attachment. \"\"\" return FileResponse ( str (( get_spotdl_path () / f \"web/sessions/ { client_id } / { file } \" ) . absolute ()), filename = file , )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.download_multiple_objects","text":"Download songs using Song objects.","title":"download_multiple_objects()"},{"location":"reference/console/web/#spotdl.console.web.download_multiple_objects--arguments","text":"songs: The list of Song objects.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.download_multiple_objects--returns","text":"returns a list of Tuple of Song and Path if the song was downloaded. Source code in spotdl/console/web.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 @app . server . post ( \"/api/download/multiple_objects\" ) def download_multiple_objects ( songs : List [ SongModel ], ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download songs using Song objects. ### Arguments - songs: The list of Song objects. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( [ Song . from_dict ( song . dict ()) for song in songs ] )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.download_multiple_search","text":"Search for song and download the first result.","title":"download_multiple_search()"},{"location":"reference/console/web/#spotdl.console.web.download_multiple_search--arguments","text":"query: The query to search.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.download_multiple_search--returns","text":"returns a list of Tuple of Song and Path if the song was downloaded. Source code in spotdl/console/web.py 440 441 442 443 444 445 446 447 448 449 450 451 452 @app . server . post ( \"/api/download/multiple_search\" ) def download_multiple_search ( query : List [ str ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( parse_query ( query ))","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.download_objects","text":"Download songs using Song objects.","title":"download_objects()"},{"location":"reference/console/web/#spotdl.console.web.download_objects--arguments","text":"song: The Song object. return_file: If True, return the file instead of the song.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.download_objects--returns","text":"returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. Source code in spotdl/console/web.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 @app . server . post ( \"/api/download/objects\" ) async def download_objects ( song : SongModel , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Download songs using Song objects. ### Arguments - song: The Song object. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song_obj , path = await app . downloader . pool_download ( Song ( ** song . dict ())) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song_obj , path","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.download_search","text":"Search for song and download the first result.","title":"download_search()"},{"location":"reference/console/web/#spotdl.console.web.download_search--arguments","text":"query: The query to search. return_file: If True, return the file instead of the song.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.download_search--returns","text":"returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. Source code in spotdl/console/web.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 @app . server . post ( \"/api/downloader/download/search\" ) async def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song , path = await app . downloader . pool_download ( Song . from_search_term ( query )) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song , path","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.download_url","text":"Download songs using Song url.","title":"download_url()"},{"location":"reference/console/web/#spotdl.console.web.download_url--arguments","text":"url: The url to download. client_id: The client's ID.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.download_url--returns","text":"returns the file path if the song was downloaded. Source code in spotdl/console/web.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 @app . server . post ( \"/api/download/url\" ) async def download_url ( url : str , client_id : str ) -> Optional [ str ]: \"\"\" Download songs using Song url. ### Arguments - url: The url to download. - client_id: The client's ID. ### Returns - returns the file path if the song was downloaded. \"\"\" app . downloader . output = str ( ( get_spotdl_path () / f \"web/sessions/ { client_id } \" ) . absolute () ) # Initiate realtime updates if websocket from client is connected ws_instance = WSProgressHandler . get ( client_id ) if ws_instance is not None : app . downloader . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ app . settings [ \"log_level\" ]], simple_tui = True , update_callback = ws_instance . update , ) try : # Fetch song metadata song = Song . from_url ( url ) # Download Song _ , path = await app . downloader . pool_download ( song ) if path is None : exc = DownloaderError ( f \"Failure downloading { song . name } \" ) logging . warning ( \"Error downloading! %s \" , exc ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exc } \" ) # Strip Filename filename = os . path . basename ( path ) return filename except Exception as exception : logging . warning ( \"Error downloading! %s \" , exception ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exception } \" ) from exception","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.fix_mime_types","text":"Fix incorrect entries in the mimetypes registry. On Windows, the Python standard library's mimetypes reads in mappings from file extension to MIME type from the Windows registry. Other applications can and do write incorrect values to this registry, which causes mimetypes.guess_type to return incorrect values, which causes spotDL to fail to render on the frontend. This method hard-codes the correct mappings for certain MIME types that are known to be either used by TensorBoard or problematic in general. Source code in spotdl/console/web.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def fix_mime_types (): \"\"\"Fix incorrect entries in the `mimetypes` registry. On Windows, the Python standard library's `mimetypes` reads in mappings from file extension to MIME type from the Windows registry. Other applications can and do write incorrect values to this registry, which causes `mimetypes.guess_type` to return incorrect values, which causes spotDL to fail to render on the frontend. This method hard-codes the correct mappings for certain MIME types that are known to be either used by TensorBoard or problematic in general. \"\"\" # Known to be problematic when Visual Studio is installed: # <https://github.com/tensorflow/tensorboard/issues/3120> # https://github.com/spotDL/spotify-downloader/issues/1540 mimetypes . add_type ( \"application/javascript\" , \".js\" ) # Not known to be problematic, but used by spotDL: mimetypes . add_type ( \"text/css\" , \".css\" ) mimetypes . add_type ( \"image/svg+xml\" , \".svg\" ) mimetypes . add_type ( \"text/html\" , \".html\" )","title":"fix_mime_types()"},{"location":"reference/console/web/#spotdl.console.web.get_settings","text":"Return the settings object.","title":"get_settings()"},{"location":"reference/console/web/#spotdl.console.web.get_settings--returns","text":"returns the settings object. Source code in spotdl/console/web.py 474 475 476 477 478 479 480 481 482 483 @app . server . get ( \"/api/settings\" ) def get_settings () -> SettingsModel : \"\"\" Return the settings object. ### Returns - returns the settings object. \"\"\" return SettingsModel ( ** app . settings )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.query_search","text":"Parse a list of search queries.","title":"query_search()"},{"location":"reference/console/web/#spotdl.console.web.query_search--arguments","text":"query: The query to parse.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.query_search--returns","text":"returns a list of Song objects. Source code in spotdl/console/web.py 269 270 271 272 273 274 275 276 277 278 279 280 281 @app . server . post ( \"/api/songs/query\" ) def query_search ( query : List [ str ]) -> List [ Song ]: \"\"\" Parse a list of search queries. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return parse_query ( query )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.search_search","text":"Parse search term and return list of Song objects.","title":"search_search()"},{"location":"reference/console/web/#spotdl.console.web.search_search--arguments","text":"query: The query to parse.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.search_search--returns","text":"returns a list of Song objects. Source code in spotdl/console/web.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 @app . server . get ( \"/api/songs/search\" ) def search_search ( query : str ) -> List [ Song ]: \"\"\" Parse search term and return list of Song objects. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" # return parse_query([query], app.downloader.threads) return get_search_results ( query )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.song_from_search","text":"Search for a song on spotify using search query.","title":"song_from_search()"},{"location":"reference/console/web/#spotdl.console.web.song_from_search--arguments","text":"query: The search query.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.song_from_search--returns","text":"returns the first result as a Song object. Source code in spotdl/console/web.py 239 240 241 242 243 244 245 246 247 248 249 250 251 @app . server . get ( \"/api/song/search\" ) def song_from_search ( query : str ) -> Song : \"\"\" Search for a song on spotify using search query. ### Arguments - query: The search query. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_search_term ( query )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.song_from_url","text":"Search for a song on spotify using url.","title":"song_from_url()"},{"location":"reference/console/web/#spotdl.console.web.song_from_url--arguments","text":"url: The url to search.","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.song_from_url--returns","text":"returns the first result as a Song object. Source code in spotdl/console/web.py 254 255 256 257 258 259 260 261 262 263 264 265 266 @app . server . get ( \"/api/song/url\" ) def song_from_url ( url : str ) -> Song : \"\"\" Search for a song on spotify using url. ### Arguments - url: The url to search. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_url ( url )","title":"Returns"},{"location":"reference/console/web/#spotdl.console.web.web","text":"Run the web server.","title":"web()"},{"location":"reference/console/web/#spotdl.console.web.web--arguments","text":"settings: Settings dictionary, based on the SettingsModel class. Source code in spotdl/console/web.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def web ( settings : Dict [ str , Any ]): \"\"\" Run the web server. ### Arguments - settings: Settings dictionary, based on the `SettingsModel` class. \"\"\" fix_mime_types () web_app_dir = str ( get_spotdl_path () . absolute ()) print ( \"Updating web app\" ) # Get web client from CDN (github for now) download_github_dir ( \"https://github.com/spotdl/web-ui/tree/master/dist\" , output_dir = web_app_dir ) # Serve web client SPA app . server . mount ( \"/\" , SPAStaticFiles ( directory = web_app_dir + \"/dist\" , html = True ), name = \"static\" ) loop = asyncio . new_event_loop () app . loop = loop app . settings = settings app . downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], log_level = settings [ \"log_level\" ], simple_tui = True , loop = loop , ) config = Config ( app = app . server , port = 8800 , workers = 1 , loop = loop ) # type: ignore server = Server ( config ) webbrowser . open ( \"http://localhost:8800\" ) loop . run_until_complete ( server . serve ()) app . downloader . progress_handler . close ()","title":"Arguments"},{"location":"reference/console/web/#spotdl.console.web.websocket_endpoint","text":"Websocket endpoint.","title":"websocket_endpoint()"},{"location":"reference/console/web/#spotdl.console.web.websocket_endpoint--arguments","text":"websocket: The WebSocket instance. client_id: The client's ID. Source code in spotdl/console/web.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @app . server . websocket ( \"/api/ws\" ) async def websocket_endpoint ( websocket : WebSocket , client_id : str ): \"\"\" Websocket endpoint. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" await WSProgressHandler ( websocket , client_id ) . connect () try : while True : data = await websocket . receive_text () logging . debug ( \"Client %s said: %s \" , client_id , data ) except WebSocketDisconnect : logging . info ( \"Disconnecting WebSocket: %s \" , client_id )","title":"Arguments"},{"location":"reference/download/","text":"Download module that holds the downloader and progress handler classes.","title":"download"},{"location":"reference/download/downloader/","text":"Downloader module, this is where all the downloading pre/post processing happens etc. Downloader ( audio_providers = None , lyrics_providers = None , ffmpeg = 'ffmpeg' , bitrate = None , ffmpeg_args = None , output_format = 'mp3' , threads = 4 , output = '.' , save_file = None , overwrite = 'skip' , cookie_file = None , filter_results = True , search_query = None , log_level = 'INFO' , simple_tui = False , loop = None , restrict = False , print_errors = False , sponsor_block = False ) \u00a4 Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc. Arguments \u00a4 audio_provider: Audio providers to use. lyrics_provider: The lyrics providers to use. ffmpeg: The ffmpeg executable to use. variable_bitrate: The variable bitrate to use. constant_bitrate: The constant bitrate to use. ffmpeg_args: The ffmpeg arguments to use. output_format: The output format to use. threads: The number of threads to use. output: The output directory to use. save_file: The save file to use when saving/loading song metadata. overwrite: The overwrite mode to use (force/skip). cookie_file: The cookie file to use for yt-dlp. filter_results: Whether to filter results. search_query: The search query to use. log_level: The log level to use. simple_tui: Whether to use simple tui. loop: The event loop to use. restrict: Whether to restrict the filename to ASCII characters. print_errors: Whether to print errors on exit. sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. Notes \u00a4 search-query uses the same format as output . if audio_provider or lyrics_provider is a list, then if no match is found, the next provider in the list will be used. Source code in spotdl/download/downloader.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def __init__ ( self , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : Optional [ str ] = None , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Downloader class. ### Arguments - audio_provider: Audio providers to use. - lyrics_provider: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. - if `audio_provider` or `lyrics_provider` is a list, then if no match is found, the next provider in the list will be used. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] audio_providers_classes : List [ Type [ AudioProvider ]] = [] lyrics_providers_classes : List [ Type [ LyricsProvider ]] = [] for provider in audio_providers : new_audio_provider = AUDIO_PROVIDERS . get ( provider ) if new_audio_provider is None : raise DownloaderError ( f \"Invalid audio provider: { provider } \" ) audio_providers_classes . append ( new_audio_provider ) if len ( audio_providers_classes ) == 0 : raise DownloaderError ( \"No audio providers specified. Please specify at least one.\" ) for provider in lyrics_providers : new_lyrics_provider = LYRICS_PROVIDERS . get ( provider ) if new_lyrics_provider is None : raise DownloaderError ( f \"Invalid lyrics provider: { provider } \" ) lyrics_providers_classes . append ( new_lyrics_provider ) if loop is None : if sys . platform == \"win32\" : # ProactorEventLoop is required on Windows to run subprocess asynchronously # it is default since Python 3.8 but has to be changed for previous versions self . loop = asyncio . ProactorEventLoop () else : self . loop = asyncio . new_event_loop () asyncio . set_event_loop ( self . loop ) else : self . loop = loop # semaphore is required to limit concurrent asyncio executions self . semaphore = asyncio . Semaphore ( threads ) # thread pool executor is used to run blocking (CPU-bound) code from a thread self . thread_executor = concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) # If ffmpeg is the default value and it's not installed # try to use the spotdl's ffmpeg if ffmpeg == \"ffmpeg\" and shutil . which ( \"ffmpeg\" ) is None : ffmpeg_exec = get_ffmpeg_path () if ffmpeg_exec is None : raise DownloaderError ( \"ffmpeg is not installed\" ) ffmpeg = str ( ffmpeg_exec . absolute ()) self . output = output self . output_format = output_format self . save_file = save_file self . threads = threads self . cookie_file = cookie_file self . overwrite = overwrite self . search_query = search_query self . filter_results = filter_results self . ffmpeg = ffmpeg self . bitrate = bitrate self . ffmpeg_args = ffmpeg_args self . restrict = restrict self . print_errors = print_errors self . errors : List [ str ] = [] self . sponsor_block = sponsor_block self . audio_providers_classes = audio_providers_classes self . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ log_level ], simple_tui ) self . lyrics_providers : List [ LyricsProvider ] = [] for lyrics_provider_class in lyrics_providers_classes : self . lyrics_providers . append ( lyrics_provider_class ()) self . progress_handler . debug ( \"Downloader initialized\" ) download_multiple_songs ( songs ) \u00a4 Download multiple songs to the temp directory. Arguments \u00a4 songs: The songs to download. Returns \u00a4 list of tuples with the song and the path to the downloaded file if successful. Source code in spotdl/download/downloader.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self . pool_download ( song ) for song in songs ] # call all task asynchronously, and wait until all are finished results = list ( self . loop . run_until_complete ( self . _aggregate_tasks ( tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ([ song . json for song , _ in results ], save_file , indent = 4 ) return results download_song ( song ) \u00a4 Download a single song. Arguments \u00a4 song: The song to download. Returns \u00a4 tuple with the song and the path to the downloaded file if successful. Source code in spotdl/download/downloader.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def download_song ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ([ song ]) return results [ 0 ] pool_download ( song ) async \u00a4 Run asynchronous task in a pool to make sure that all processes. Arguments \u00a4 song: The song to download. Returns \u00a4 tuple with the song and the path to the downloaded file if successful. Notes \u00a4 This method calls self.search_and_download in a new thread. Source code in spotdl/download/downloader.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 async def pool_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it's free # only certain amount of tasks can acquire the semaphore at the same time async with self . semaphore : # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn't # hurt performance. return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song ) search ( song ) \u00a4 Search for a song using all available providers. Arguments \u00a4 song: The song to search for. Returns \u00a4 tuple with download url and audio provider if successful. Source code in spotdl/download/downloader.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" audio_providers : List [ AudioProvider ] = [] for audio_provider_class in self . audio_providers_classes : audio_providers . append ( audio_provider_class ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) ) for audio_provider in audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \" { audio_provider . name } failed to find { song . display_name } \" ) raise LookupError ( f \"No results found for song: { song . display_name } \" ) search_and_download ( song ) \u00a4 Search for the song and download it. Arguments \u00a4 song: The song to download. Returns \u00a4 tuple with the song and the path to the downloaded file if successful. Notes \u00a4 This function is synchronous. Source code in spotdl/download/downloader.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def search_and_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it's None extract the current metadata # And reinitialize the song object if song . name is None and song . url : data = song . json new_data = Song . from_url ( data [ \"url\" ]) . json data . update (( k , v ) for k , v in new_data . items () if v is not None ) if data . get ( \"song_list\" ): # Reinitialize the correct song list object data [ \"song_list\" ] = song . song_list . __class__ ( ** data [ \"song_list\" ]) # Reinitialize the song object song = Song ( ** data ) # Create the output file path output_file = create_file_name ( song , self . output , self . output_format ) temp_folder = get_temp_path () # Restrict the filename if needed if self . restrict is True : output_file = restrict_filename ( output_file ) # If the file already exists and we don't want to overwrite it, # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping { song . display_name } \" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don't skip if the file exists and overwrite is set to force if output_file . exists () and self . overwrite == \"force\" : self . progress_handler . debug ( f \"Overwriting { song . display_name } \" ) # Initalize the progress tracker display_progress_tracker = self . progress_handler . get_new_tracker ( song ) # Create the output directory if it doesn't exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) self . progress_handler . debug ( f \"Downloading { song . display_name } using { url } , \" f \"audio provider: { audio_provider . name } \" ) # Add progress hook to the audio provider audio_provider . audio_handler . add_progress_hook ( display_progress_tracker . yt_dlp_progress_hook ) # Download the song using yt-dlp download_info = audio_provider . get_download_metadata ( url , download = True ) temp_file = Path ( temp_folder / f \" { download_info [ 'id' ] } . { download_info [ 'ext' ] } \" ) if download_info is None : self . progress_handler . debug ( f \"No download info found for { song . display_name } , url: { url } \" ) raise LookupError ( f \"yt-dlp failed to get metadata for: { song . name } - { song . artist } \" ) display_progress_tracker . notify_download_complete () success , result = convert ( temp_file , output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . ffmpeg_progress_hook , ) # Remove the temp file if temp_file . exists (): temp_file . unlink () if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_ { datetime . datetime . now () . strftime ( '%Y-%m- %d -%H-%M-%S' ) } .txt\" ) error_message = \"\" for key , value in result . items (): error_message += f \"### { key } : \\n { str ( value ) . strip () } \\n\\n \" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert if output_file . exists (): output_file . unlink () raise FFmpegError ( f \"Failed to convert { song . display_name } , \" f \"you can find error here: { str ( file_name . absolute ()) } \" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song's download url if song . download_url is None : song . download_url = download_info [ \"webpage_url\" ] display_progress_tracker . notify_conversion_complete () if self . sponsor_block : post_processor = SponsorBlockPP ( audio_provider . audio_handler , SPONSOR_BLOCK_CATEGORIES ) _ , download_info = post_processor . run ( download_info ) chapters = download_info [ \"sponsorblock_chapters\" ] if len ( chapters ) > 0 : self . progress_handler . log ( f \"Removing { len ( chapters ) } sponsor segments for { song . display_name } \" ) modify_chapters = ModifyChaptersPP ( audio_provider . audio_handler , remove_sponsor_segments = SPONSOR_BLOCK_CATEGORIES , ) files_to_delete , download_info = modify_chapters . run ( download_info ) for file_to_delete in files_to_delete : Path ( file_to_delete ) . unlink () try : song . lyrics = self . search_lyrics ( song ) except LookupError : self . progress_handler . debug ( f \"No lyrics found for { song . display_name } , \" \"lyrics providers: \" f \" { ', ' . join ([ lprovider . name for lprovider in self . lyrics_providers ]) } \" ) try : embed_metadata ( output_file , song , self . output_format ) except Exception as exception : raise MetadataError ( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker . notify_complete () self . progress_handler . log ( f 'Downloaded \" { song . display_name } \": { song . download_url } ' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \" { song . url } - { exception . __class__ . __name__ } : { exception } \" ) return song , None search_lyrics ( song ) \u00a4 Search for lyrics using all available providers. Arguments \u00a4 song: The song to search for. Returns \u00a4 lyrics if successful. Source code in spotdl/download/downloader.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for { song . display_name } on { lyrics_provider . name } \" ) return lyrics self . progress_handler . debug ( f \" { lyrics_provider . name } failed to find lyrics \" f \"for { song . display_name } \" ) raise LookupError ( f \"No lyrics found for song: { song . display_name } \" ) DownloaderError \u00a4 Bases: Exception Base class for all exceptions related to downloaders.","title":"downloader"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader","text":"Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc.","title":"Downloader"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader--arguments","text":"audio_provider: Audio providers to use. lyrics_provider: The lyrics providers to use. ffmpeg: The ffmpeg executable to use. variable_bitrate: The variable bitrate to use. constant_bitrate: The constant bitrate to use. ffmpeg_args: The ffmpeg arguments to use. output_format: The output format to use. threads: The number of threads to use. output: The output directory to use. save_file: The save file to use when saving/loading song metadata. overwrite: The overwrite mode to use (force/skip). cookie_file: The cookie file to use for yt-dlp. filter_results: Whether to filter results. search_query: The search query to use. log_level: The log level to use. simple_tui: Whether to use simple tui. loop: The event loop to use. restrict: Whether to restrict the filename to ASCII characters. print_errors: Whether to print errors on exit. sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader--notes","text":"search-query uses the same format as output . if audio_provider or lyrics_provider is a list, then if no match is found, the next provider in the list will be used. Source code in spotdl/download/downloader.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def __init__ ( self , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : Optional [ str ] = None , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Downloader class. ### Arguments - audio_provider: Audio providers to use. - lyrics_provider: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. - if `audio_provider` or `lyrics_provider` is a list, then if no match is found, the next provider in the list will be used. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] audio_providers_classes : List [ Type [ AudioProvider ]] = [] lyrics_providers_classes : List [ Type [ LyricsProvider ]] = [] for provider in audio_providers : new_audio_provider = AUDIO_PROVIDERS . get ( provider ) if new_audio_provider is None : raise DownloaderError ( f \"Invalid audio provider: { provider } \" ) audio_providers_classes . append ( new_audio_provider ) if len ( audio_providers_classes ) == 0 : raise DownloaderError ( \"No audio providers specified. Please specify at least one.\" ) for provider in lyrics_providers : new_lyrics_provider = LYRICS_PROVIDERS . get ( provider ) if new_lyrics_provider is None : raise DownloaderError ( f \"Invalid lyrics provider: { provider } \" ) lyrics_providers_classes . append ( new_lyrics_provider ) if loop is None : if sys . platform == \"win32\" : # ProactorEventLoop is required on Windows to run subprocess asynchronously # it is default since Python 3.8 but has to be changed for previous versions self . loop = asyncio . ProactorEventLoop () else : self . loop = asyncio . new_event_loop () asyncio . set_event_loop ( self . loop ) else : self . loop = loop # semaphore is required to limit concurrent asyncio executions self . semaphore = asyncio . Semaphore ( threads ) # thread pool executor is used to run blocking (CPU-bound) code from a thread self . thread_executor = concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) # If ffmpeg is the default value and it's not installed # try to use the spotdl's ffmpeg if ffmpeg == \"ffmpeg\" and shutil . which ( \"ffmpeg\" ) is None : ffmpeg_exec = get_ffmpeg_path () if ffmpeg_exec is None : raise DownloaderError ( \"ffmpeg is not installed\" ) ffmpeg = str ( ffmpeg_exec . absolute ()) self . output = output self . output_format = output_format self . save_file = save_file self . threads = threads self . cookie_file = cookie_file self . overwrite = overwrite self . search_query = search_query self . filter_results = filter_results self . ffmpeg = ffmpeg self . bitrate = bitrate self . ffmpeg_args = ffmpeg_args self . restrict = restrict self . print_errors = print_errors self . errors : List [ str ] = [] self . sponsor_block = sponsor_block self . audio_providers_classes = audio_providers_classes self . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ log_level ], simple_tui ) self . lyrics_providers : List [ LyricsProvider ] = [] for lyrics_provider_class in lyrics_providers_classes : self . lyrics_providers . append ( lyrics_provider_class ()) self . progress_handler . debug ( \"Downloader initialized\" )","title":"Notes"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs","text":"Download multiple songs to the temp directory.","title":"download_multiple_songs()"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs--arguments","text":"songs: The songs to download.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs--returns","text":"list of tuples with the song and the path to the downloaded file if successful. Source code in spotdl/download/downloader.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self . pool_download ( song ) for song in songs ] # call all task asynchronously, and wait until all are finished results = list ( self . loop . run_until_complete ( self . _aggregate_tasks ( tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ([ song . json for song , _ in results ], save_file , indent = 4 ) return results","title":"Returns"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song","text":"Download a single song.","title":"download_song()"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song--arguments","text":"song: The song to download.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song--returns","text":"tuple with the song and the path to the downloaded file if successful. Source code in spotdl/download/downloader.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def download_song ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ([ song ]) return results [ 0 ]","title":"Returns"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download","text":"Run asynchronous task in a pool to make sure that all processes.","title":"pool_download()"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--arguments","text":"song: The song to download.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--returns","text":"tuple with the song and the path to the downloaded file if successful.","title":"Returns"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--notes","text":"This method calls self.search_and_download in a new thread. Source code in spotdl/download/downloader.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 async def pool_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it's free # only certain amount of tasks can acquire the semaphore at the same time async with self . semaphore : # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn't # hurt performance. return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song )","title":"Notes"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search","text":"Search for a song using all available providers.","title":"search()"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search--arguments","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search--returns","text":"tuple with download url and audio provider if successful. Source code in spotdl/download/downloader.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" audio_providers : List [ AudioProvider ] = [] for audio_provider_class in self . audio_providers_classes : audio_providers . append ( audio_provider_class ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) ) for audio_provider in audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \" { audio_provider . name } failed to find { song . display_name } \" ) raise LookupError ( f \"No results found for song: { song . display_name } \" )","title":"Returns"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download","text":"Search for the song and download it.","title":"search_and_download()"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--arguments","text":"song: The song to download.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--returns","text":"tuple with the song and the path to the downloaded file if successful.","title":"Returns"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--notes","text":"This function is synchronous. Source code in spotdl/download/downloader.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def search_and_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it's None extract the current metadata # And reinitialize the song object if song . name is None and song . url : data = song . json new_data = Song . from_url ( data [ \"url\" ]) . json data . update (( k , v ) for k , v in new_data . items () if v is not None ) if data . get ( \"song_list\" ): # Reinitialize the correct song list object data [ \"song_list\" ] = song . song_list . __class__ ( ** data [ \"song_list\" ]) # Reinitialize the song object song = Song ( ** data ) # Create the output file path output_file = create_file_name ( song , self . output , self . output_format ) temp_folder = get_temp_path () # Restrict the filename if needed if self . restrict is True : output_file = restrict_filename ( output_file ) # If the file already exists and we don't want to overwrite it, # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping { song . display_name } \" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don't skip if the file exists and overwrite is set to force if output_file . exists () and self . overwrite == \"force\" : self . progress_handler . debug ( f \"Overwriting { song . display_name } \" ) # Initalize the progress tracker display_progress_tracker = self . progress_handler . get_new_tracker ( song ) # Create the output directory if it doesn't exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) self . progress_handler . debug ( f \"Downloading { song . display_name } using { url } , \" f \"audio provider: { audio_provider . name } \" ) # Add progress hook to the audio provider audio_provider . audio_handler . add_progress_hook ( display_progress_tracker . yt_dlp_progress_hook ) # Download the song using yt-dlp download_info = audio_provider . get_download_metadata ( url , download = True ) temp_file = Path ( temp_folder / f \" { download_info [ 'id' ] } . { download_info [ 'ext' ] } \" ) if download_info is None : self . progress_handler . debug ( f \"No download info found for { song . display_name } , url: { url } \" ) raise LookupError ( f \"yt-dlp failed to get metadata for: { song . name } - { song . artist } \" ) display_progress_tracker . notify_download_complete () success , result = convert ( temp_file , output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . ffmpeg_progress_hook , ) # Remove the temp file if temp_file . exists (): temp_file . unlink () if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_ { datetime . datetime . now () . strftime ( '%Y-%m- %d -%H-%M-%S' ) } .txt\" ) error_message = \"\" for key , value in result . items (): error_message += f \"### { key } : \\n { str ( value ) . strip () } \\n\\n \" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert if output_file . exists (): output_file . unlink () raise FFmpegError ( f \"Failed to convert { song . display_name } , \" f \"you can find error here: { str ( file_name . absolute ()) } \" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song's download url if song . download_url is None : song . download_url = download_info [ \"webpage_url\" ] display_progress_tracker . notify_conversion_complete () if self . sponsor_block : post_processor = SponsorBlockPP ( audio_provider . audio_handler , SPONSOR_BLOCK_CATEGORIES ) _ , download_info = post_processor . run ( download_info ) chapters = download_info [ \"sponsorblock_chapters\" ] if len ( chapters ) > 0 : self . progress_handler . log ( f \"Removing { len ( chapters ) } sponsor segments for { song . display_name } \" ) modify_chapters = ModifyChaptersPP ( audio_provider . audio_handler , remove_sponsor_segments = SPONSOR_BLOCK_CATEGORIES , ) files_to_delete , download_info = modify_chapters . run ( download_info ) for file_to_delete in files_to_delete : Path ( file_to_delete ) . unlink () try : song . lyrics = self . search_lyrics ( song ) except LookupError : self . progress_handler . debug ( f \"No lyrics found for { song . display_name } , \" \"lyrics providers: \" f \" { ', ' . join ([ lprovider . name for lprovider in self . lyrics_providers ]) } \" ) try : embed_metadata ( output_file , song , self . output_format ) except Exception as exception : raise MetadataError ( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker . notify_complete () self . progress_handler . log ( f 'Downloaded \" { song . display_name } \": { song . download_url } ' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \" { song . url } - { exception . __class__ . __name__ } : { exception } \" ) return song , None","title":"Notes"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics","text":"Search for lyrics using all available providers.","title":"search_lyrics()"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics--arguments","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics--returns","text":"lyrics if successful. Source code in spotdl/download/downloader.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for { song . display_name } on { lyrics_provider . name } \" ) return lyrics self . progress_handler . debug ( f \" { lyrics_provider . name } failed to find lyrics \" f \"for { song . display_name } \" ) raise LookupError ( f \"No lyrics found for song: { song . display_name } \" )","title":"Returns"},{"location":"reference/download/downloader/#spotdl.download.downloader.DownloaderError","text":"Bases: Exception Base class for all exceptions related to downloaders.","title":"DownloaderError"},{"location":"reference/download/progress_handler/","text":"Module that holds the ProgressHandler class and Song Tracker class. ProgressHandler ( log_level = INFO , simple_tui = False , update_callback = None ) \u00a4 Class for handing the progress of a download, including the progress bar. Arguments \u00a4 log_level: The log level to use. simple_tui: Whether or not to use the simple TUI. update_callback: A callback to call when the progress bar is updated. Source code in spotdl/download/progress_handler.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def __init__ ( self , log_level : int = INFO , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], None ]] = None , ): \"\"\" Initialize the progress handler. ### Arguments - log_level: The log level to use. - simple_tui: Whether or not to use the simple TUI. - update_callback: A callback to call when the progress bar is updated. \"\"\" self . songs : List [ Song ] = [] self . song_count : int = 0 self . overall_progress = 0 self . overall_total = 100 self . overall_completed_tasks = 0 self . update_callback = update_callback self . previous_overall = self . overall_completed_tasks if log_level not in LEVEL_TO_NAME : raise ProgressHandlerError ( f \"Invalid log level: { log_level } \" ) self . log_level = log_level self . simple_tui = simple_tui self . quiet = self . log_level < 10 self . overall_task_id : Optional [ TaskID ] = None if not self . simple_tui : # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying self . is_legacy = detect_legacy_windows () # dumb_terminals automatically handled by rich. Color system is too but it is incorrect # for legacy windows ... so no color for y'all. self . console = Console ( theme = THEME , color_system = \"truecolor\" if not self . is_legacy else None ) self . rich_progress_bar = Progress ( SizedTextColumn ( \"[white] {task.description} \" , overflow = \"ellipsis\" , width = int ( self . console . width / 3 ), ), SizedTextColumn ( \" {task.fields[message]} \" , width = 18 , style = \"nonimportant\" ), BarColumn ( bar_width = None , finished_style = \"green\" ), \"[progress.percentage] {task.percentage:>3.0f} %\" , TimeRemainingColumn (), console = self . console , # Normally when you exit the progress context manager (or call stop()) # the last refreshed display remains in the terminal with the cursor on # the following line. You can also make the progress display disappear on # exit by setting transient=True on the Progress constructor transient = self . is_legacy , ) # Basically a wrapper for rich's: with ... as ... self . rich_progress_bar . __enter__ () else : logging . basicConfig ( format = \" %(asctime)s - %(levelname)s - %(message)s \" , datefmt = \"%H:%M:%S\" , level = self . log_level , ) add_song ( song ) \u00a4 Adds a song to the list of songs. Arguments \u00a4 song: The song to add. Source code in spotdl/download/progress_handler.py 220 221 222 223 224 225 226 227 228 229 def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs )) close () \u00a4 Close the Tui Progress Handler. Source code in spotdl/download/progress_handler.py 364 365 366 367 368 369 370 371 372 def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown () debug ( message ) \u00a4 Debug message. Arguments \u00a4 message: The message to log. Source code in spotdl/download/progress_handler.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue] { message } \" ) else : logging . debug ( message ) error ( message ) \u00a4 Error message. Arguments \u00a4 message: The message to log. Source code in spotdl/download/progress_handler.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red] { message } \" ) else : logging . error ( message ) get_new_tracker ( song ) \u00a4 Get a new progress tracker. Arguments \u00a4 song: The song to track. Returns \u00a4 A new progress tracker. Source code in spotdl/download/progress_handler.py 351 352 353 354 355 356 357 358 359 360 361 362 def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song ) log ( message ) \u00a4 Log message. Arguments \u00a4 message: The message to log. Source code in spotdl/download/progress_handler.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green] { message } \" ) else : logging . info ( message ) set_song_count ( count ) \u00a4 Set the number of songs to download. Arguments \u00a4 count: The number of songs to download. Source code in spotdl/download/progress_handler.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \" { self . overall_completed_tasks } / { int ( self . overall_total / 100 ) } \" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), ) set_songs ( songs ) \u00a4 Sets the list of songs to be downloaded. Arguments \u00a4 songs: The list of songs to download. Source code in spotdl/download/progress_handler.py 231 232 233 234 235 236 237 238 239 240 def set_songs ( self , songs : List [ Song ]) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs )) update_overall () \u00a4 Update the overall progress bar. Source code in spotdl/download/progress_handler.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \" { self . overall_completed_tasks } /\" f \" { int ( self . overall_total / 100 ) } \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \" %s / %s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks warn ( message ) \u00a4 Warning message. Arguments \u00a4 message: The message to log. Source code in spotdl/download/progress_handler.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow] { message } \" ) else : logging . warning ( message ) ProgressHandlerError \u00a4 Bases: Exception Base class for all exceptions raised by ProgressHandler subclasses. SizedTextColumn ( text_format , style = 'none' , justify = 'left' , markup = True , highlighter = None , overflow = None , width = 20 ) \u00a4 Bases: ProgressColumn Custom sized text column based on the Rich library. Arguments \u00a4 text_format: The format string to use for the text. style: The style to use for the text. justify: The justification to use for the text. markup: Whether or not the text should be rendered as markup. highlighter: A Highlighter to use for highlighting the text. overflow: The overflow method to use for truncating the text. width: The maximum width of the text. Source code in spotdl/download/progress_handler.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , text_format : str , style : StyleType = \"none\" , justify : JustifyMethod = \"left\" , markup : bool = True , highlighter : Optional [ Highlighter ] = None , overflow : Optional [ OverflowMethod ] = None , width : int = 20 , ) -> None : \"\"\" A column containing text. ### Arguments - text_format: The format string to use for the text. - style: The style to use for the text. - justify: The justification to use for the text. - markup: Whether or not the text should be rendered as markup. - highlighter: A Highlighter to use for highlighting the text. - overflow: The overflow method to use for truncating the text. - width: The maximum width of the text. \"\"\" self . text_format = text_format self . justify : JustifyMethod = justify self . style = style self . markup = markup self . highlighter = highlighter self . overflow : Optional [ OverflowMethod ] = overflow self . width = width super () . __init__ () render ( task ) \u00a4 Render the Column. Arguments \u00a4 task: The Task to render. Returns \u00a4 A Text object. Source code in spotdl/download/progress_handler.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text SongTracker ( parent , song ) \u00a4 Class to track the progress of a song. Arguments \u00a4 parent: The parent Tui Progress Handler. Source code in spotdl/download/progress_handler.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __init__ ( self , parent , song : Song ) -> None : \"\"\" Initialize the Tui Song Tracker. ### Arguments - parent: The parent Tui Progress Handler. \"\"\" self . parent : \"ProgressHandler\" = parent self . song = song self . progress : int = 0 self . old_progress : int = 0 self . status = \"\" if not self . parent . simple_tui : self . task_id = self . parent . rich_progress_bar . add_task ( description = song . display_name , message = \"Download Started\" , total = 100 , completed = self . progress , start = False , visible = ( not self . parent . quiet ), ) ffmpeg_progress_hook ( progress ) \u00a4 Updates the progress. Arguments \u00a4 progress: The progress to update to. Source code in spotdl/download/progress_handler.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 def ffmpeg_progress_hook ( self , progress : int ) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" if not self . parent . simple_tui : self . progress = 50 + int ( progress * 0.45 ) else : self . progress = 50 self . update ( \"Converting\" ) notify_complete ( status = 'Done' ) \u00a4 Notifies the progress handler that the song has been downloaded and converted. Arguments \u00a4 status: The status to display. Source code in spotdl/download/progress_handler.py 488 489 490 491 492 493 494 495 496 497 def notify_complete ( self , status = \"Done\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) notify_conversion_complete ( status = 'Converting' ) \u00a4 Notifies the progress handler that the song has been converted. Arguments \u00a4 status: The status to display. Source code in spotdl/download/progress_handler.py 477 478 479 480 481 482 483 484 485 486 def notify_conversion_complete ( self , status = \"Converting\" ) -> None : \"\"\" Notifies the progress handler that the song has been converted. ### Arguments - status: The status to display. \"\"\" self . progress = 95 self . update ( status ) notify_download_complete ( status = 'Embedding metadata' ) \u00a4 Notifies the progress handler that the song has been downloaded. Arguments \u00a4 status: The status to display. Source code in spotdl/download/progress_handler.py 466 467 468 469 470 471 472 473 474 475 def notify_download_complete ( self , status = \"Embedding metadata\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\"\" self . progress = 50 self . update ( status ) notify_download_skip ( status = 'Skipped' ) \u00a4 Notifies the progress handler that the song has been skipped. Arguments \u00a4 status: The status to display. Source code in spotdl/download/progress_handler.py 499 500 501 502 503 504 505 506 507 508 def notify_download_skip ( self , status = \"Skipped\" ) -> None : \"\"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) notify_error ( message , traceback ) \u00a4 Logs an error message. Arguments \u00a4 message: The message to log. traceback: The traceback of the error. Source code in spotdl/download/progress_handler.py 452 453 454 455 456 457 458 459 460 461 462 463 464 def notify_error ( self , message : str , traceback : Exception ) -> None : \"\"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\"\" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \" { traceback . __class__ . __name__ } : { traceback } \" ) update ( message = '' ) \u00a4 Called at every event. Arguments \u00a4 message: The message to display. Source code in spotdl/download/progress_handler.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 def update ( self , message = \"\" ): \"\"\" Called at every event. ### Arguments - message: The message to display. \"\"\" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 if delta : self . parent . log ( f \" { self . song . name } - { self . song . artist } : { message } \" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message ) yt_dlp_progress_hook ( data ) \u00a4 Updates the progress. Arguments \u00a4 progress: The progress to update to. Source code in spotdl/download/progress_handler.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def yt_dlp_progress_hook ( self , data : Dict [ str , Any ]) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" if data [ \"status\" ] == \"downloading\" : file_bytes = data [ \"total_bytes\" ] downloaded_bytes = data [ \"downloaded_bytes\" ] if self . parent . simple_tui : self . progress = 50 elif file_bytes and downloaded_bytes : self . progress = downloaded_bytes / file_bytes * 50 self . update ( \"Downloading\" )","title":"progress_handler"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler","text":"Class for handing the progress of a download, including the progress bar.","title":"ProgressHandler"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler--arguments","text":"log_level: The log level to use. simple_tui: Whether or not to use the simple TUI. update_callback: A callback to call when the progress bar is updated. Source code in spotdl/download/progress_handler.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def __init__ ( self , log_level : int = INFO , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], None ]] = None , ): \"\"\" Initialize the progress handler. ### Arguments - log_level: The log level to use. - simple_tui: Whether or not to use the simple TUI. - update_callback: A callback to call when the progress bar is updated. \"\"\" self . songs : List [ Song ] = [] self . song_count : int = 0 self . overall_progress = 0 self . overall_total = 100 self . overall_completed_tasks = 0 self . update_callback = update_callback self . previous_overall = self . overall_completed_tasks if log_level not in LEVEL_TO_NAME : raise ProgressHandlerError ( f \"Invalid log level: { log_level } \" ) self . log_level = log_level self . simple_tui = simple_tui self . quiet = self . log_level < 10 self . overall_task_id : Optional [ TaskID ] = None if not self . simple_tui : # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying self . is_legacy = detect_legacy_windows () # dumb_terminals automatically handled by rich. Color system is too but it is incorrect # for legacy windows ... so no color for y'all. self . console = Console ( theme = THEME , color_system = \"truecolor\" if not self . is_legacy else None ) self . rich_progress_bar = Progress ( SizedTextColumn ( \"[white] {task.description} \" , overflow = \"ellipsis\" , width = int ( self . console . width / 3 ), ), SizedTextColumn ( \" {task.fields[message]} \" , width = 18 , style = \"nonimportant\" ), BarColumn ( bar_width = None , finished_style = \"green\" ), \"[progress.percentage] {task.percentage:>3.0f} %\" , TimeRemainingColumn (), console = self . console , # Normally when you exit the progress context manager (or call stop()) # the last refreshed display remains in the terminal with the cursor on # the following line. You can also make the progress display disappear on # exit by setting transient=True on the Progress constructor transient = self . is_legacy , ) # Basically a wrapper for rich's: with ... as ... self . rich_progress_bar . __enter__ () else : logging . basicConfig ( format = \" %(asctime)s - %(levelname)s - %(message)s \" , datefmt = \"%H:%M:%S\" , level = self . log_level , )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.add_song","text":"Adds a song to the list of songs.","title":"add_song()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.add_song--arguments","text":"song: The song to add. Source code in spotdl/download/progress_handler.py 220 221 222 223 224 225 226 227 228 229 def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs ))","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.close","text":"Close the Tui Progress Handler. Source code in spotdl/download/progress_handler.py 364 365 366 367 368 369 370 371 372 def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown ()","title":"close()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.debug","text":"Debug message.","title":"debug()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.debug--arguments","text":"message: The message to log. Source code in spotdl/download/progress_handler.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue] { message } \" ) else : logging . debug ( message )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.error","text":"Error message.","title":"error()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.error--arguments","text":"message: The message to log. Source code in spotdl/download/progress_handler.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red] { message } \" ) else : logging . error ( message )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker","text":"Get a new progress tracker.","title":"get_new_tracker()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker--arguments","text":"song: The song to track.","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker--returns","text":"A new progress tracker. Source code in spotdl/download/progress_handler.py 351 352 353 354 355 356 357 358 359 360 361 362 def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song )","title":"Returns"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.log","text":"Log message.","title":"log()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.log--arguments","text":"message: The message to log. Source code in spotdl/download/progress_handler.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green] { message } \" ) else : logging . info ( message )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_song_count","text":"Set the number of songs to download.","title":"set_song_count()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_song_count--arguments","text":"count: The number of songs to download. Source code in spotdl/download/progress_handler.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \" { self . overall_completed_tasks } / { int ( self . overall_total / 100 ) } \" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_songs","text":"Sets the list of songs to be downloaded.","title":"set_songs()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_songs--arguments","text":"songs: The list of songs to download. Source code in spotdl/download/progress_handler.py 231 232 233 234 235 236 237 238 239 240 def set_songs ( self , songs : List [ Song ]) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs ))","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.update_overall","text":"Update the overall progress bar. Source code in spotdl/download/progress_handler.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \" { self . overall_completed_tasks } /\" f \" { int ( self . overall_total / 100 ) } \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \" %s / %s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks","title":"update_overall()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.warn","text":"Warning message.","title":"warn()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.warn--arguments","text":"message: The message to log. Source code in spotdl/download/progress_handler.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow] { message } \" ) else : logging . warning ( message )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandlerError","text":"Bases: Exception Base class for all exceptions raised by ProgressHandler subclasses.","title":"ProgressHandlerError"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn","text":"Bases: ProgressColumn Custom sized text column based on the Rich library.","title":"SizedTextColumn"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn--arguments","text":"text_format: The format string to use for the text. style: The style to use for the text. justify: The justification to use for the text. markup: Whether or not the text should be rendered as markup. highlighter: A Highlighter to use for highlighting the text. overflow: The overflow method to use for truncating the text. width: The maximum width of the text. Source code in spotdl/download/progress_handler.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , text_format : str , style : StyleType = \"none\" , justify : JustifyMethod = \"left\" , markup : bool = True , highlighter : Optional [ Highlighter ] = None , overflow : Optional [ OverflowMethod ] = None , width : int = 20 , ) -> None : \"\"\" A column containing text. ### Arguments - text_format: The format string to use for the text. - style: The style to use for the text. - justify: The justification to use for the text. - markup: Whether or not the text should be rendered as markup. - highlighter: A Highlighter to use for highlighting the text. - overflow: The overflow method to use for truncating the text. - width: The maximum width of the text. \"\"\" self . text_format = text_format self . justify : JustifyMethod = justify self . style = style self . markup = markup self . highlighter = highlighter self . overflow : Optional [ OverflowMethod ] = overflow self . width = width super () . __init__ ()","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render","text":"Render the Column.","title":"render()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render--arguments","text":"task: The Task to render.","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render--returns","text":"A Text object. Source code in spotdl/download/progress_handler.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text","title":"Returns"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker","text":"Class to track the progress of a song.","title":"SongTracker"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker--arguments","text":"parent: The parent Tui Progress Handler. Source code in spotdl/download/progress_handler.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __init__ ( self , parent , song : Song ) -> None : \"\"\" Initialize the Tui Song Tracker. ### Arguments - parent: The parent Tui Progress Handler. \"\"\" self . parent : \"ProgressHandler\" = parent self . song = song self . progress : int = 0 self . old_progress : int = 0 self . status = \"\" if not self . parent . simple_tui : self . task_id = self . parent . rich_progress_bar . add_task ( description = song . display_name , message = \"Download Started\" , total = 100 , completed = self . progress , start = False , visible = ( not self . parent . quiet ), )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.ffmpeg_progress_hook","text":"Updates the progress.","title":"ffmpeg_progress_hook()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.ffmpeg_progress_hook--arguments","text":"progress: The progress to update to. Source code in spotdl/download/progress_handler.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 def ffmpeg_progress_hook ( self , progress : int ) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" if not self . parent . simple_tui : self . progress = 50 + int ( progress * 0.45 ) else : self . progress = 50 self . update ( \"Converting\" )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_complete","text":"Notifies the progress handler that the song has been downloaded and converted.","title":"notify_complete()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_complete--arguments","text":"status: The status to display. Source code in spotdl/download/progress_handler.py 488 489 490 491 492 493 494 495 496 497 def notify_complete ( self , status = \"Done\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_conversion_complete","text":"Notifies the progress handler that the song has been converted.","title":"notify_conversion_complete()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_conversion_complete--arguments","text":"status: The status to display. Source code in spotdl/download/progress_handler.py 477 478 479 480 481 482 483 484 485 486 def notify_conversion_complete ( self , status = \"Converting\" ) -> None : \"\"\" Notifies the progress handler that the song has been converted. ### Arguments - status: The status to display. \"\"\" self . progress = 95 self . update ( status )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_complete","text":"Notifies the progress handler that the song has been downloaded.","title":"notify_download_complete()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_complete--arguments","text":"status: The status to display. Source code in spotdl/download/progress_handler.py 466 467 468 469 470 471 472 473 474 475 def notify_download_complete ( self , status = \"Embedding metadata\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\"\" self . progress = 50 self . update ( status )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_skip","text":"Notifies the progress handler that the song has been skipped.","title":"notify_download_skip()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_skip--arguments","text":"status: The status to display. Source code in spotdl/download/progress_handler.py 499 500 501 502 503 504 505 506 507 508 def notify_download_skip ( self , status = \"Skipped\" ) -> None : \"\"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_error","text":"Logs an error message.","title":"notify_error()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_error--arguments","text":"message: The message to log. traceback: The traceback of the error. Source code in spotdl/download/progress_handler.py 452 453 454 455 456 457 458 459 460 461 462 463 464 def notify_error ( self , message : str , traceback : Exception ) -> None : \"\"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\"\" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \" { traceback . __class__ . __name__ } : { traceback } \" )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.update","text":"Called at every event.","title":"update()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.update--arguments","text":"message: The message to display. Source code in spotdl/download/progress_handler.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 def update ( self , message = \"\" ): \"\"\" Called at every event. ### Arguments - message: The message to display. \"\"\" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 if delta : self . parent . log ( f \" { self . song . name } - { self . song . artist } : { message } \" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message )","title":"Arguments"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.yt_dlp_progress_hook","text":"Updates the progress.","title":"yt_dlp_progress_hook()"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.yt_dlp_progress_hook--arguments","text":"progress: The progress to update to. Source code in spotdl/download/progress_handler.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def yt_dlp_progress_hook ( self , data : Dict [ str , Any ]) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" if data [ \"status\" ] == \"downloading\" : file_bytes = data [ \"total_bytes\" ] downloaded_bytes = data [ \"downloaded_bytes\" ] if self . parent . simple_tui : self . progress = 50 elif file_bytes and downloaded_bytes : self . progress = downloaded_bytes / file_bytes * 50 self . update ( \"Downloading\" )","title":"Arguments"},{"location":"reference/providers/","text":"Different types of data providers for spotdl.","title":"providers"},{"location":"reference/providers/audio/","text":"Audio providers for spotdl.","title":"audio"},{"location":"reference/providers/audio/base/","text":"Base audio provider module. AudioProvider ( output_format = 'mp3' , cookie_file = None , search_query = None , filter_results = True ) \u00a4 Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler. Arguments \u00a4 output_directory: The directory to save the downloaded songs to. output_format: The format to save the downloaded songs in. cookie_file: The path to a file containing cookies to be used by YTDL. search_query: The query to use when searching for songs. filter_results: Whether to filter results. Errors \u00a4 raises NotImplementedError if self.name is not set. Source code in spotdl/providers/audio/base.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , output_format : str = \"mp3\" , cookie_file : Optional [ str ] = None , search_query : Optional [ str ] = None , filter_results : bool = True , ) -> None : \"\"\" Base class for audio providers. ### Arguments - output_directory: The directory to save the downloaded songs to. - output_format: The format to save the downloaded songs in. - cookie_file: The path to a file containing cookies to be used by YTDL. - search_query: The query to use when searching for songs. - filter_results: Whether to filter results. ### Errors - raises `NotImplementedError` if self.name is not set. \"\"\" self . output_format = output_format self . cookie_file = cookie_file self . search_query = search_query self . filter_results = filter_results if self . output_format == \"m4a\" : ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\" elif self . output_format == \"opus\" : ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\" else : ytdl_format = \"bestaudio\" self . audio_handler = YoutubeDL ( { \"format\" : ytdl_format , \"quiet\" : True , \"no_warnings\" : True , \"encoding\" : \"UTF-8\" , \"logger\" : YTDLLogger (), \"cookiefile\" : self . cookie_file , \"outtmpl\" : f \" { get_temp_path () } /%(id)s.%(ext)s\" , \"retries\" : 5 , } ) get_download_metadata ( url , download = False ) \u00a4 Get metadata for a download using yt-dlp. Arguments \u00a4 url: The url to get metadata for. Returns \u00a4 A dictionary containing the metadata. Source code in spotdl/providers/audio/base.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_download_metadata ( self , url : str , download : bool = False ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" try : data = self . audio_handler . extract_info ( url , download = download ) if data : return data except Exception as exception : raise AudioProviderError ( f \"YT-DLP download error - { url } \" ) from exception raise AudioProviderError ( f \"No metadata found for the provided url { url } \" ) get_results ( search_term , ** kwargs ) \u00a4 Get results from audio provider. Arguments \u00a4 search_term: The search term to use. kwargs: Additional arguments. Returns \u00a4 A list of results. Source code in spotdl/providers/audio/base.py 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_results ( self , search_term : str , ** kwargs ): \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError name () property \u00a4 Get the name of the provider. Returns \u00a4 The name of the provider. Source code in spotdl/providers/audio/base.py 161 162 163 164 165 166 167 168 169 170 @property def name ( self ) -> str : \"\"\" Get the name of the provider. ### Returns - The name of the provider. \"\"\" return self . __class__ . __name__ order_results ( results , song ) \u00a4 Order results. Arguments \u00a4 results: The results to order. song: The song to order for. Returns \u00a4 The ordered results. Source code in spotdl/providers/audio/base.py 125 126 127 128 129 130 131 132 133 134 135 136 137 def order_results ( self , results , song : Song ): \"\"\" Order results. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" raise NotImplementedError search ( song ) \u00a4 Search for a song and return best match. Arguments \u00a4 song: The song to search for. Returns \u00a4 The url of the best match or None if no match was found. Source code in spotdl/providers/audio/base.py 98 99 100 101 102 103 104 105 106 107 108 109 def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError AudioProviderError \u00a4 Bases: Exception Base class for all exceptions related to audio searching/downloading. YTDLLogger \u00a4 Custom YT-dlp logger. debug ( msg ) \u00a4 YTDL uses this to print debug messages. Source code in spotdl/providers/audio/base.py 24 25 26 27 28 29 def debug ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107 error ( msg ) \u00a4 YTDL uses this to print errors. Source code in spotdl/providers/audio/base.py 38 39 40 41 42 43 def error ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise AudioProviderError ( msg ) warning ( msg ) \u00a4 YTDL uses this to print warnings. Source code in spotdl/providers/audio/base.py 31 32 33 34 35 36 def warning ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107","title":"base"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider","text":"Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler.","title":"AudioProvider"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider--arguments","text":"output_directory: The directory to save the downloaded songs to. output_format: The format to save the downloaded songs in. cookie_file: The path to a file containing cookies to be used by YTDL. search_query: The query to use when searching for songs. filter_results: Whether to filter results.","title":"Arguments"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider--errors","text":"raises NotImplementedError if self.name is not set. Source code in spotdl/providers/audio/base.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , output_format : str = \"mp3\" , cookie_file : Optional [ str ] = None , search_query : Optional [ str ] = None , filter_results : bool = True , ) -> None : \"\"\" Base class for audio providers. ### Arguments - output_directory: The directory to save the downloaded songs to. - output_format: The format to save the downloaded songs in. - cookie_file: The path to a file containing cookies to be used by YTDL. - search_query: The query to use when searching for songs. - filter_results: Whether to filter results. ### Errors - raises `NotImplementedError` if self.name is not set. \"\"\" self . output_format = output_format self . cookie_file = cookie_file self . search_query = search_query self . filter_results = filter_results if self . output_format == \"m4a\" : ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\" elif self . output_format == \"opus\" : ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\" else : ytdl_format = \"bestaudio\" self . audio_handler = YoutubeDL ( { \"format\" : ytdl_format , \"quiet\" : True , \"no_warnings\" : True , \"encoding\" : \"UTF-8\" , \"logger\" : YTDLLogger (), \"cookiefile\" : self . cookie_file , \"outtmpl\" : f \" { get_temp_path () } /%(id)s.%(ext)s\" , \"retries\" : 5 , } )","title":"Errors"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata","text":"Get metadata for a download using yt-dlp.","title":"get_download_metadata()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata--arguments","text":"url: The url to get metadata for.","title":"Arguments"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata--returns","text":"A dictionary containing the metadata. Source code in spotdl/providers/audio/base.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_download_metadata ( self , url : str , download : bool = False ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" try : data = self . audio_handler . extract_info ( url , download = download ) if data : return data except Exception as exception : raise AudioProviderError ( f \"YT-DLP download error - { url } \" ) from exception raise AudioProviderError ( f \"No metadata found for the provided url { url } \" )","title":"Returns"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results","text":"Get results from audio provider.","title":"get_results()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results--arguments","text":"search_term: The search term to use. kwargs: Additional arguments.","title":"Arguments"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results--returns","text":"A list of results. Source code in spotdl/providers/audio/base.py 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_results ( self , search_term : str , ** kwargs ): \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.name","text":"Get the name of the provider.","title":"name()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.name--returns","text":"The name of the provider. Source code in spotdl/providers/audio/base.py 161 162 163 164 165 166 167 168 169 170 @property def name ( self ) -> str : \"\"\" Get the name of the provider. ### Returns - The name of the provider. \"\"\" return self . __class__ . __name__","title":"Returns"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.order_results","text":"Order results.","title":"order_results()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.order_results--arguments","text":"results: The results to order. song: The song to order for.","title":"Arguments"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.order_results--returns","text":"The ordered results. Source code in spotdl/providers/audio/base.py 125 126 127 128 129 130 131 132 133 134 135 136 137 def order_results ( self , results , song : Song ): \"\"\" Order results. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search","text":"Search for a song and return best match.","title":"search()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search--arguments","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search--returns","text":"The url of the best match or None if no match was found. Source code in spotdl/providers/audio/base.py 98 99 100 101 102 103 104 105 106 107 108 109 def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProviderError","text":"Bases: Exception Base class for all exceptions related to audio searching/downloading.","title":"AudioProviderError"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger","text":"Custom YT-dlp logger.","title":"YTDLLogger"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.debug","text":"YTDL uses this to print debug messages. Source code in spotdl/providers/audio/base.py 24 25 26 27 28 29 def debug ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107","title":"debug()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.error","text":"YTDL uses this to print errors. Source code in spotdl/providers/audio/base.py 38 39 40 41 42 43 def error ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise AudioProviderError ( msg )","title":"error()"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.warning","text":"YTDL uses this to print warnings. Source code in spotdl/providers/audio/base.py 31 32 33 34 35 36 def warning ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107","title":"warning()"},{"location":"reference/providers/audio/youtube/","text":"Youtube module for downloading and searching songs. YouTube \u00a4 Bases: AudioProvider YouTube audio provider class get_results ( search_term , * _args , ** _kwargs ) staticmethod \u00a4 Get results from YouTube Arguments \u00a4 search_term: The search term to search for. args: Unused. kwargs: Unused. Returns \u00a4 A list of YouTube results if found, None otherwise. Source code in spotdl/providers/audio/youtube.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @staticmethod def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List [ PyTube ]]: # pylint: disable=W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search ( search_term ) . results order_results ( results , song ) \u00a4 Filter results based on the song's metadata. Arguments \u00a4 results: The results to order. song: The song to order for. Returns \u00a4 The ordered results. Source code in spotdl/providers/audio/youtube.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def order_results ( self , results : List [ PyTube ], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify ( song . name ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) for result in results : # Skip results without id if result . video_id is None : continue # Slugify some variables slug_result_name = slugify ( result . title ) sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) # Check for common words in result name common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song's artist list for artist in song . artists : artist_match_number += fuzz . partial_token_sort_ratio ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70% artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = fuzz . partial_token_sort_ratio ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result . watch_url ] = average_match return links_with_match_value search ( song ) \u00a4 Search for a video on YouTube. Arguments \u00a4 song: The song to search for. Returns \u00a4 The url of the best match or None if no match was found. Source code in spotdl/providers/audio/youtube.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self . get_results ( search_query ) if results is None : return None if self . filter_results : ordered_results = { results [ 0 ] . watch_url : 100 } else : # Order results ordered_results = self . order_results ( results , song ) # No matches found if len ( ordered_results ) == 0 : return None result_items = list ( ordered_results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Return the first result return sorted_results [ 0 ][ 0 ]","title":"youtube"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube","text":"Bases: AudioProvider YouTube audio provider class","title":"YouTube"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results","text":"Get results from YouTube","title":"get_results()"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results--arguments","text":"search_term: The search term to search for. args: Unused. kwargs: Unused.","title":"Arguments"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results--returns","text":"A list of YouTube results if found, None otherwise. Source code in spotdl/providers/audio/youtube.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @staticmethod def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List [ PyTube ]]: # pylint: disable=W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search ( search_term ) . results","title":"Returns"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.order_results","text":"Filter results based on the song's metadata.","title":"order_results()"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.order_results--arguments","text":"results: The results to order. song: The song to order for.","title":"Arguments"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.order_results--returns","text":"The ordered results. Source code in spotdl/providers/audio/youtube.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def order_results ( self , results : List [ PyTube ], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify ( song . name ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) for result in results : # Skip results without id if result . video_id is None : continue # Slugify some variables slug_result_name = slugify ( result . title ) sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) # Check for common words in result name common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song's artist list for artist in song . artists : artist_match_number += fuzz . partial_token_sort_ratio ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70% artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = fuzz . partial_token_sort_ratio ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result . watch_url ] = average_match return links_with_match_value","title":"Returns"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.search","text":"Search for a video on YouTube.","title":"search()"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.search--arguments","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.search--returns","text":"The url of the best match or None if no match was found. Source code in spotdl/providers/audio/youtube.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self . get_results ( search_query ) if results is None : return None if self . filter_results : ordered_results = { results [ 0 ] . watch_url : 100 } else : # Order results ordered_results = self . order_results ( results , song ) # No matches found if len ( ordered_results ) == 0 : return None result_items = list ( ordered_results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Return the first result return sorted_results [ 0 ][ 0 ]","title":"Returns"},{"location":"reference/providers/audio/ytmusic/","text":"YTMusic module for downloading and searching songs. YouTubeMusic ( * args , ** kwargs ) \u00a4 Bases: AudioProvider YouTube Music audio provider class Arguments \u00a4 args: Arguments passed to the AudioProvider class. kwargs: Keyword arguments passed to the AudioProvider class. Source code in spotdl/providers/audio/ytmusic.py 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Initialize the YouTube Music API ### Arguments - args: Arguments passed to the `AudioProvider` class. - kwargs: Keyword arguments passed to the `AudioProvider` class. \"\"\" super () . __init__ ( * args , ** kwargs ) self . client = YTMusic () get_results ( search_term , ** kwargs ) \u00a4 Get results from YouTube Music API and simplify them Arguments \u00a4 search_term: The search term to search for. kwargs: other keyword arguments passed to the YTMusic.search method. Returns \u00a4 A list of simplified results (dicts) Source code in spotdl/providers/audio/ytmusic.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]]: \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result is None or result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v= { result [ 'videoId' ] } \" , \"album\" : result . get ( \"album\" , {}) . get ( \"name\" ) if result . get ( \"album\" ) else None , \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results order_results ( results , song ) \u00a4 Filter results based on the song's metadata. Arguments \u00a4 results: The results to filter. song: The song to filter by. Returns \u00a4 A dict of filtered results. Source code in spotdl/providers/audio/ytmusic.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) slug_result_artists = slugify ( result [ \"artists\" ]) slug_result_album = ( slugify ( result [ \"album\" ]) if result . get ( \"album\" ) else None ) # check for common words in result name sentence_words = slug_song_name . split ( \"-\" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # DEBUG CODE # print(f\"#############################\") # print(f\"slug_result_name: {slug_result_name}\") # print(f\"slug_result_artists: {slug_result_artists}\") # print(f\"slug_result_album: {slug_result_album}\") # print(f\"slug_song_name: {slug_song_name}\") # print(f\"slug_album_name: {slug_album_name}\") # print(f\"slug_song_artist: {slug_song_artist}\") # print(f\"slug_song_title: {slug_song_title}\") # print(f\"URL - {result['link']}\") # print(\"-----------------------------\") # skip results that have no common words in their name # print(f\"common_word: {common_word}\") if not common_word : continue artist_match_number = 0 for artist in song . artists : # print(\"song.artist\", artist) # print(\"slugify artist\", slugify(artist)) for slugified_result in [ slug_result_name , slug_result_artists ]: artist_match_number += ( 1 if slugify ( artist ) in slugified_result else 0 ) artist_match = artist_match_number * 100 / len ( song . artists ) # print(\"first artist_match: \", artist_match) # If we didn't find any artist match, # we fallback to channel name match if artist_match <= 50 and result [ \"type\" ] != \"song\" : channel_name_match = fuzz . partial_token_sort_ratio ( slugify ( song . artist ), slug_result_artists , ) if channel_name_match > artist_match_number : artist_match = channel_name_match # print(\"second artist_match: \", artist_match) # skip results with artist match lower than 70% if artist_match < 70 : # print(\"! artist_match < 70 - skipping\") continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = fuzz . partial_token_sort_ratio ( slug_result_name , slug_song_name , ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = fuzz . partial_token_sort_ratio ( f \" { slug_song_artist } - { slug_result_name } \" , slug_song_title , ) else : name_match = fuzz . partial_token_sort_ratio ( slug_result_name , slug_song_title , ) # Drop results with name match lower than 50% # print(f\"name_match: {name_match}\") if name_match < 50 : # print(\"! name_match < 50 - skipping\") continue # Find album match album_match = 0.0 # Calculate album match only for songs if result [ \"type\" ] == \"song\" : if slug_result_album : album_match = fuzz . partial_ratio ( slug_result_album , slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value # Calculate total match average_match = ( artist_match + name_match + time_match ) / 3 # print(f\"album_match: {album_match}\") # print(f\"time_match: {time_match}\") # print(f\"average_match: {average_match}\") if ( result [ \"type\" ] == \"song\" and slug_result_album and fuzz . partial_ratio ( slug_album_name , slug_result_name , score_cutoff = 95 ) and slug_result_album == slug_album_name ): # If the result album name is similar to the song album name # and the result album name is the same as the song album name # we add album match to the average match average_match = ( artist_match + album_match + name_match + time_match ) / 4 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value search ( song ) \u00a4 Search for a song on YouTube Music. Arguments \u00a4 song: The song to search for. Returns \u00a4 The url of the best match or None if no match was found. Source code in spotdl/providers/audio/ytmusic.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it's available if song . isrc : isrc_results = self . get_results ( song . isrc , filter = \"songs\" ) if len ( isrc_results ) == 1 : isrc_result = self . order_results ([ isrc_results [ 0 ]], song ) if len ( isrc_result ) == 1 : isrc_link , isrc_score = isrc_result . popitem () if isrc_score > 90 : # print(f\"# RETURN URL - {isrc_link} - isrc score\") return isrc_link search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ]: 100 } # song type results are always more accurate than video type, # so if we get score of 80 or above # we are almost 100% sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ]) if songs [ best_result ] >= 80 : # print(f\"# RETURN URL - {best_result} - song >= 80\") return best_result # We didn't find the correct song on the first try so now we get video type results # add them to song_results, and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ]: 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # print(f\"# RETURN URL - {sorted_results[0][0]} - sorted\") # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ]","title":"ytmusic"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic","text":"Bases: AudioProvider YouTube Music audio provider class","title":"YouTubeMusic"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic--arguments","text":"args: Arguments passed to the AudioProvider class. kwargs: Keyword arguments passed to the AudioProvider class. Source code in spotdl/providers/audio/ytmusic.py 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Initialize the YouTube Music API ### Arguments - args: Arguments passed to the `AudioProvider` class. - kwargs: Keyword arguments passed to the `AudioProvider` class. \"\"\" super () . __init__ ( * args , ** kwargs ) self . client = YTMusic ()","title":"Arguments"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results","text":"Get results from YouTube Music API and simplify them","title":"get_results()"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results--arguments","text":"search_term: The search term to search for. kwargs: other keyword arguments passed to the YTMusic.search method.","title":"Arguments"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results--returns","text":"A list of simplified results (dicts) Source code in spotdl/providers/audio/ytmusic.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]]: \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result is None or result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v= { result [ 'videoId' ] } \" , \"album\" : result . get ( \"album\" , {}) . get ( \"name\" ) if result . get ( \"album\" ) else None , \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results","title":"Returns"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.order_results","text":"Filter results based on the song's metadata.","title":"order_results()"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.order_results--arguments","text":"results: The results to filter. song: The song to filter by.","title":"Arguments"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.order_results--returns","text":"A dict of filtered results. Source code in spotdl/providers/audio/ytmusic.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) slug_result_artists = slugify ( result [ \"artists\" ]) slug_result_album = ( slugify ( result [ \"album\" ]) if result . get ( \"album\" ) else None ) # check for common words in result name sentence_words = slug_song_name . split ( \"-\" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # DEBUG CODE # print(f\"#############################\") # print(f\"slug_result_name: {slug_result_name}\") # print(f\"slug_result_artists: {slug_result_artists}\") # print(f\"slug_result_album: {slug_result_album}\") # print(f\"slug_song_name: {slug_song_name}\") # print(f\"slug_album_name: {slug_album_name}\") # print(f\"slug_song_artist: {slug_song_artist}\") # print(f\"slug_song_title: {slug_song_title}\") # print(f\"URL - {result['link']}\") # print(\"-----------------------------\") # skip results that have no common words in their name # print(f\"common_word: {common_word}\") if not common_word : continue artist_match_number = 0 for artist in song . artists : # print(\"song.artist\", artist) # print(\"slugify artist\", slugify(artist)) for slugified_result in [ slug_result_name , slug_result_artists ]: artist_match_number += ( 1 if slugify ( artist ) in slugified_result else 0 ) artist_match = artist_match_number * 100 / len ( song . artists ) # print(\"first artist_match: \", artist_match) # If we didn't find any artist match, # we fallback to channel name match if artist_match <= 50 and result [ \"type\" ] != \"song\" : channel_name_match = fuzz . partial_token_sort_ratio ( slugify ( song . artist ), slug_result_artists , ) if channel_name_match > artist_match_number : artist_match = channel_name_match # print(\"second artist_match: \", artist_match) # skip results with artist match lower than 70% if artist_match < 70 : # print(\"! artist_match < 70 - skipping\") continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = fuzz . partial_token_sort_ratio ( slug_result_name , slug_song_name , ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = fuzz . partial_token_sort_ratio ( f \" { slug_song_artist } - { slug_result_name } \" , slug_song_title , ) else : name_match = fuzz . partial_token_sort_ratio ( slug_result_name , slug_song_title , ) # Drop results with name match lower than 50% # print(f\"name_match: {name_match}\") if name_match < 50 : # print(\"! name_match < 50 - skipping\") continue # Find album match album_match = 0.0 # Calculate album match only for songs if result [ \"type\" ] == \"song\" : if slug_result_album : album_match = fuzz . partial_ratio ( slug_result_album , slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value # Calculate total match average_match = ( artist_match + name_match + time_match ) / 3 # print(f\"album_match: {album_match}\") # print(f\"time_match: {time_match}\") # print(f\"average_match: {average_match}\") if ( result [ \"type\" ] == \"song\" and slug_result_album and fuzz . partial_ratio ( slug_album_name , slug_result_name , score_cutoff = 95 ) and slug_result_album == slug_album_name ): # If the result album name is similar to the song album name # and the result album name is the same as the song album name # we add album match to the average match average_match = ( artist_match + album_match + name_match + time_match ) / 4 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value","title":"Returns"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.search","text":"Search for a song on YouTube Music.","title":"search()"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.search--arguments","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.search--returns","text":"The url of the best match or None if no match was found. Source code in spotdl/providers/audio/ytmusic.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it's available if song . isrc : isrc_results = self . get_results ( song . isrc , filter = \"songs\" ) if len ( isrc_results ) == 1 : isrc_result = self . order_results ([ isrc_results [ 0 ]], song ) if len ( isrc_result ) == 1 : isrc_link , isrc_score = isrc_result . popitem () if isrc_score > 90 : # print(f\"# RETURN URL - {isrc_link} - isrc score\") return isrc_link search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ]: 100 } # song type results are always more accurate than video type, # so if we get score of 80 or above # we are almost 100% sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ]) if songs [ best_result ] >= 80 : # print(f\"# RETURN URL - {best_result} - song >= 80\") return best_result # We didn't find the correct song on the first try so now we get video type results # add them to song_results, and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ]: 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # print(f\"# RETURN URL - {sorted_results[0][0]} - sorted\") # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ]","title":"Returns"},{"location":"reference/providers/lyrics/","text":"Lyrics providers for spotdl.","title":"lyrics"},{"location":"reference/providers/lyrics/azlyrics/","text":"AZLyrics lyrics module. AzLyrics \u00a4 Bases: LyricsProvider AZLyrics lyrics provider class. get_lyrics ( name , artists , ** _ ) \u00a4 Try to get lyrics from azlyrics Arguments \u00a4 name: The name of the song. artists: The artists of the song. Returns \u00a4 The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/azlyrics.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ) . lower () song_artists = artist_str . replace ( \" \" , \"+\" ) . lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q= { song_name } + { artists } \" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don't have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) # Find the div with the longest text lyrics_div = sorted ( div_tags , key = lambda x : len ( x . text ))[ - 1 ] lyrics = lyrics_div . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3 :] return lyrics","title":"azlyrics"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics","text":"Bases: LyricsProvider AZLyrics lyrics provider class.","title":"AzLyrics"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_lyrics","text":"Try to get lyrics from azlyrics","title":"get_lyrics()"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_lyrics--arguments","text":"name: The name of the song. artists: The artists of the song.","title":"Arguments"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_lyrics--returns","text":"The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/azlyrics.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ) . lower () song_artists = artist_str . replace ( \" \" , \"+\" ) . lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q= { song_name } + { artists } \" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don't have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) # Find the div with the longest text lyrics_div = sorted ( div_tags , key = lambda x : len ( x . text ))[ - 1 ] lyrics = lyrics_div . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3 :] return lyrics","title":"Returns"},{"location":"reference/providers/lyrics/base/","text":"Base module for all other lyrics providers. LyricsProvider () \u00a4 Base class for all other lyrics providers. Source code in spotdl/providers/lyrics/base.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self ): \"\"\" Init the lyrics provider searchand set headers. \"\"\" self . headers = { \"Connection\" : \"keep-alive\" , \"Pragma\" : \"no-cache\" , \"Cache-Control\" : \"no-cache\" , \"sec-ch-ua\" : '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"' , \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36\" , \"Accept\" : \"*/*\" , \"Sec-Fetch-Site\" : \"same-origin\" , \"Sec-Fetch-Mode\" : \"cors\" , \"Sec-Fetch-Dest\" : \"empty\" , \"Accept-Language\" : \"en-US;q=0.8,en;q=0.7\" , } get_lyrics ( name , artists , ** kwargs ) \u00a4 Returns the lyrics for the given song. Arguments \u00a4 name: The name of the song. artists: The artists of the song. kwargs: Additional arguments. Returns \u00a4 The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/base.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError name () property \u00a4 Returns the name of the lyrics provider. Source code in spotdl/providers/lyrics/base.py 47 48 49 50 51 52 53 @property def name ( self ) -> str : \"\"\" Returns the name of the lyrics provider. \"\"\" return self . __class__ . __name__","title":"base"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider","text":"Base class for all other lyrics providers. Source code in spotdl/providers/lyrics/base.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self ): \"\"\" Init the lyrics provider searchand set headers. \"\"\" self . headers = { \"Connection\" : \"keep-alive\" , \"Pragma\" : \"no-cache\" , \"Cache-Control\" : \"no-cache\" , \"sec-ch-ua\" : '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"' , \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36\" , \"Accept\" : \"*/*\" , \"Sec-Fetch-Site\" : \"same-origin\" , \"Sec-Fetch-Mode\" : \"cors\" , \"Sec-Fetch-Dest\" : \"empty\" , \"Accept-Language\" : \"en-US;q=0.8,en;q=0.7\" , }","title":"LyricsProvider"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics","text":"Returns the lyrics for the given song.","title":"get_lyrics()"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics--arguments","text":"name: The name of the song. artists: The artists of the song. kwargs: Additional arguments.","title":"Arguments"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics--returns","text":"The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/base.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.name","text":"Returns the name of the lyrics provider. Source code in spotdl/providers/lyrics/base.py 47 48 49 50 51 52 53 @property def name ( self ) -> str : \"\"\" Returns the name of the lyrics provider. \"\"\" return self . __class__ . __name__","title":"name()"},{"location":"reference/providers/lyrics/genius/","text":"Genius Lyrics module. Genius \u00a4 Bases: LyricsProvider Genius lyrics provider class. get_lyrics ( name , artists , ** _ ) \u00a4 Try to get lyrics from genius Arguments \u00a4 name: The name of the song. artists: The artists of the song. Returns \u00a4 The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/genius.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \" { name } { artist_str } \" }, headers = headers , ) song_id = search_response . json ()[ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/ { song_id } \" , headers = headers ) song_url = song_response . json ()[ \"response\" ][ \"song\" ][ \"url\" ] counter = 0 soup = None while counter > 5 : genius_page_response = requests . get ( song_url , headers = self . headers ) print ( genius_page_response . text ) if not genius_page_response . ok : counter += 1 continue soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \" \\n \" ), \"html.parser\" ) break if soup is None : return None lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text () . strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \" \\n \" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None","title":"genius"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius","text":"Bases: LyricsProvider Genius lyrics provider class.","title":"Genius"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_lyrics","text":"Try to get lyrics from genius","title":"get_lyrics()"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_lyrics--arguments","text":"name: The name of the song. artists: The artists of the song.","title":"Arguments"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_lyrics--returns","text":"The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/genius.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \" { name } { artist_str } \" }, headers = headers , ) song_id = search_response . json ()[ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/ { song_id } \" , headers = headers ) song_url = song_response . json ()[ \"response\" ][ \"song\" ][ \"url\" ] counter = 0 soup = None while counter > 5 : genius_page_response = requests . get ( song_url , headers = self . headers ) print ( genius_page_response . text ) if not genius_page_response . ok : counter += 1 continue soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \" \\n \" ), \"html.parser\" ) break if soup is None : return None lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text () . strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \" \\n \" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None","title":"Returns"},{"location":"reference/providers/lyrics/musixmatch/","text":"MusixMatch lyrics provider. MusixMatch \u00a4 Bases: LyricsProvider MusixMatch lyrics provider class. get_lyrics ( name , artists , ** kwargs ) \u00a4 Try to get lyrics from musixmatch Arguments \u00a4 name: The name of the song. artists: The artists of the song. kwargs: Additional arguments. Returns \u00a4 The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/musixmatch.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote ( f \" { name } - { artists_str } \" , safe = \"\" ) # search the `tracks page` if track_search is True if track_search : query += \"/tracks\" search_url = f \"https://www.musixmatch.com/search/ { query } \" search_resp = requests . get ( search_url , headers = self . headers ) search_soup = BeautifulSoup ( search_resp . text , \"html.parser\" ) song_url_tag = search_soup . select_one ( \"a[href^='/lyrics/']\" ) # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None : # track_serach being True means we are already searching the tracks page. if track_search : return None lyrics = self . get_lyrics ( name , artists , track_search = True ) return lyrics song_url = \"https://www.musixmatch.com\" + str ( song_url_tag . get ( \"href\" , \"\" )) lyrics_resp = requests . get ( song_url , headers = self . headers ) lyrics_soup = BeautifulSoup ( lyrics_resp . text , \"html.parser\" ) lyrics_paragraphs = lyrics_soup . select ( \"p.mxm-lyrics__content\" ) lyrics = \" \\n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None","title":"musixmatch"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch","text":"Bases: LyricsProvider MusixMatch lyrics provider class.","title":"MusixMatch"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_lyrics","text":"Try to get lyrics from musixmatch","title":"get_lyrics()"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_lyrics--arguments","text":"name: The name of the song. artists: The artists of the song. kwargs: Additional arguments.","title":"Arguments"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_lyrics--returns","text":"The lyrics of the song or None if no lyrics were found. Source code in spotdl/providers/lyrics/musixmatch.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote ( f \" { name } - { artists_str } \" , safe = \"\" ) # search the `tracks page` if track_search is True if track_search : query += \"/tracks\" search_url = f \"https://www.musixmatch.com/search/ { query } \" search_resp = requests . get ( search_url , headers = self . headers ) search_soup = BeautifulSoup ( search_resp . text , \"html.parser\" ) song_url_tag = search_soup . select_one ( \"a[href^='/lyrics/']\" ) # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None : # track_serach being True means we are already searching the tracks page. if track_search : return None lyrics = self . get_lyrics ( name , artists , track_search = True ) return lyrics song_url = \"https://www.musixmatch.com\" + str ( song_url_tag . get ( \"href\" , \"\" )) lyrics_resp = requests . get ( song_url , headers = self . headers ) lyrics_soup = BeautifulSoup ( lyrics_resp . text , \"html.parser\" ) lyrics_paragraphs = lyrics_soup . select ( \"p.mxm-lyrics__content\" ) lyrics = \" \\n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None","title":"Returns"},{"location":"reference/types/","text":"Types for the spotdl package.","title":"types"},{"location":"reference/types/album/","text":"Artist module for retrieving artist data from Spotify. Album dataclass \u00a4 Bases: SongList Album class for retrieving album data from Spotify. from_url ( url ) classmethod \u00a4 Parse an album from a Spotify URL. Arguments \u00a4 url: The URL of the album. Returns \u00a4 The Album object. Source code in spotdl/types/album.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track songs : List [ Song ] = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , ) get_metadata ( url ) staticmethod \u00a4 Get metadata for album. Arguments \u00a4 url: The URL of the album. Returns \u00a4 A dictionary with metadata. Source code in spotdl/types/album.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ], \"artist\" : album_metadata [ \"artists\" ][ 0 ], \"url\" : url , } get_urls ( url ) staticmethod \u00a4 Get urls for all songs in album. Arguments \u00a4 url: The URL of the album. Returns \u00a4 A list of urls. Source code in spotdl/types/album.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ]: album_response = spotify_client . next ( album_response ) # Failed to get response, break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ]) if album_response is None : raise AlbumError ( f \"Failed to get album response: { url } \" ) return [ track [ \"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ] AlbumError \u00a4 Bases: Exception Base class for all exceptions related to albums.","title":"album"},{"location":"reference/types/album/#spotdl.types.album.Album","text":"Bases: SongList Album class for retrieving album data from Spotify.","title":"Album"},{"location":"reference/types/album/#spotdl.types.album.Album.from_url","text":"Parse an album from a Spotify URL.","title":"from_url()"},{"location":"reference/types/album/#spotdl.types.album.Album.from_url--arguments","text":"url: The URL of the album.","title":"Arguments"},{"location":"reference/types/album/#spotdl.types.album.Album.from_url--returns","text":"The Album object. Source code in spotdl/types/album.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track songs : List [ Song ] = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , )","title":"Returns"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata","text":"Get metadata for album.","title":"get_metadata()"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata--arguments","text":"url: The URL of the album.","title":"Arguments"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata--returns","text":"A dictionary with metadata. Source code in spotdl/types/album.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ], \"artist\" : album_metadata [ \"artists\" ][ 0 ], \"url\" : url , }","title":"Returns"},{"location":"reference/types/album/#spotdl.types.album.Album.get_urls","text":"Get urls for all songs in album.","title":"get_urls()"},{"location":"reference/types/album/#spotdl.types.album.Album.get_urls--arguments","text":"url: The URL of the album.","title":"Arguments"},{"location":"reference/types/album/#spotdl.types.album.Album.get_urls--returns","text":"A list of urls. Source code in spotdl/types/album.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ]: album_response = spotify_client . next ( album_response ) # Failed to get response, break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ]) if album_response is None : raise AlbumError ( f \"Failed to get album response: { url } \" ) return [ track [ \"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ]","title":"Returns"},{"location":"reference/types/album/#spotdl.types.album.AlbumError","text":"Bases: Exception Base class for all exceptions related to albums.","title":"AlbumError"},{"location":"reference/types/artist/","text":"Artist module for retrieving artist data from Spotify. Artist dataclass \u00a4 Bases: SongList Artist class. Contains all the information about an artist. Frozen to prevent accidental modification. create_basic_list ( url ) classmethod \u00a4 Create a basic list with only the required metadata and urls. Arguments \u00a4 url: The url of the list. Returns \u00a4 The SongList object. Source code in spotdl/types/artist.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [], albums = []) from_url ( url ) classmethod \u00a4 Creates an Artist object from a URL. Arguments \u00a4 url: The URL of the artist. Returns \u00a4 The Artist object. Source code in spotdl/types/artist.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: { url } \" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above, but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type: ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , ) get_albums ( url ) staticmethod \u00a4 Returns a list with album urls. Arguments \u00a4 url: The URL of the artist. Returns \u00a4 List of album urls. Source code in spotdl/types/artist.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @staticmethod def get_albums ( url : str ) -> List [ str ]: \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ]: albums . append ( album [ \"external_urls\" ][ \"spotify\" ]) known_albums . add ( slugify ( album [ \"name\" ])) # type: ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ]: artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ]: album_name = slugify ( album [ \"name\" ]) # type: ignore if album_name in known_albums : albums . extend ([ item [ \"uri\" ] for item in artist_albums [ \"items\" ]]) known_albums . add ( album_name ) return albums get_metadata ( url ) staticmethod \u00a4 Get metadata for artist. Arguments \u00a4 url: The URL of the artist. Returns \u00a4 Dict with metadata for artist. Source code in spotdl/types/artist.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ], \"genres\" : raw_artist_meta [ \"genres\" ], \"url\" : url , } get_urls ( url ) staticmethod \u00a4 Get urls for all songs for artist. Arguments \u00a4 url: The URL of the artist. Returns \u00a4 List of urls for all songs for artist. Source code in spotdl/types/artist.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls ArtistError \u00a4 Bases: Exception Base class for all exceptions related to artists.","title":"artist"},{"location":"reference/types/artist/#spotdl.types.artist.Artist","text":"Bases: SongList Artist class. Contains all the information about an artist. Frozen to prevent accidental modification.","title":"Artist"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.create_basic_list","text":"Create a basic list with only the required metadata and urls.","title":"create_basic_list()"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.create_basic_list--arguments","text":"url: The url of the list.","title":"Arguments"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.create_basic_list--returns","text":"The SongList object. Source code in spotdl/types/artist.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [], albums = [])","title":"Returns"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.from_url","text":"Creates an Artist object from a URL.","title":"from_url()"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.from_url--arguments","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.from_url--returns","text":"The Artist object. Source code in spotdl/types/artist.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: { url } \" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above, but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type: ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , )","title":"Returns"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_albums","text":"Returns a list with album urls.","title":"get_albums()"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_albums--arguments","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_albums--returns","text":"List of album urls. Source code in spotdl/types/artist.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @staticmethod def get_albums ( url : str ) -> List [ str ]: \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ]: albums . append ( album [ \"external_urls\" ][ \"spotify\" ]) known_albums . add ( slugify ( album [ \"name\" ])) # type: ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ]: artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ]: album_name = slugify ( album [ \"name\" ]) # type: ignore if album_name in known_albums : albums . extend ([ item [ \"uri\" ] for item in artist_albums [ \"items\" ]]) known_albums . add ( album_name ) return albums","title":"Returns"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata","text":"Get metadata for artist.","title":"get_metadata()"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata--arguments","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata--returns","text":"Dict with metadata for artist. Source code in spotdl/types/artist.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ], \"genres\" : raw_artist_meta [ \"genres\" ], \"url\" : url , }","title":"Returns"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_urls","text":"Get urls for all songs for artist.","title":"get_urls()"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_urls--arguments","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_urls--returns","text":"List of urls for all songs for artist. Source code in spotdl/types/artist.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls","title":"Returns"},{"location":"reference/types/artist/#spotdl.types.artist.ArtistError","text":"Bases: Exception Base class for all exceptions related to artists.","title":"ArtistError"},{"location":"reference/types/playlist/","text":"Playlist module for retrieving playlist data from Spotify. Playlist dataclass \u00a4 Bases: SongList Playlist class for retrieving playlist data from Spotify. from_url ( url ) classmethod \u00a4 Load playlist info and tracks from a Spotify playlist URL. Arguments \u00a4 url: The URL of the playlist. Returns \u00a4 The Playlist object. Source code in spotdl/types/playlist.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) get_metadata ( url ) staticmethod \u00a4 Get metadata for a playlist. Arguments \u00a4 url: The URL of the playlist. Returns \u00a4 A dictionary with metadata. Source code in spotdl/types/playlist.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ], \"url\" : url , \"description\" : playlist [ \"description\" ], \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ], \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ], } get_urls ( url ) staticmethod \u00a4 Get URLs of all tracks in a playlist. Arguments \u00a4 url: The URL of the playlist. Returns \u00a4 A list of urls. Source code in spotdl/types/playlist.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: { url } \" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ]: playlist_response = spotify_client . next ( playlist_response ) # Failed to get response, break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ]) return [ track [ \"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ) . get ( \"id\" ) ] PlaylistError \u00a4 Bases: Exception Base class for all exceptions related to playlists.","title":"playlist"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist","text":"Bases: SongList Playlist class for retrieving playlist data from Spotify.","title":"Playlist"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.from_url","text":"Load playlist info and tracks from a Spotify playlist URL.","title":"from_url()"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.from_url--arguments","text":"url: The URL of the playlist.","title":"Arguments"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.from_url--returns","text":"The Playlist object. Source code in spotdl/types/playlist.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , )","title":"Returns"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata","text":"Get metadata for a playlist.","title":"get_metadata()"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata--arguments","text":"url: The URL of the playlist.","title":"Arguments"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata--returns","text":"A dictionary with metadata. Source code in spotdl/types/playlist.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ], \"url\" : url , \"description\" : playlist [ \"description\" ], \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ], \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ], }","title":"Returns"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_urls","text":"Get URLs of all tracks in a playlist.","title":"get_urls()"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_urls--arguments","text":"url: The URL of the playlist.","title":"Arguments"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_urls--returns","text":"A list of urls. Source code in spotdl/types/playlist.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: { url } \" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ]: playlist_response = spotify_client . next ( playlist_response ) # Failed to get response, break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ]) return [ track [ \"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ) . get ( \"id\" ) ]","title":"Returns"},{"location":"reference/types/playlist/#spotdl.types.playlist.PlaylistError","text":"Bases: Exception Base class for all exceptions related to playlists.","title":"PlaylistError"},{"location":"reference/types/saved/","text":"Saved module for handing the saved tracks from user library Saved dataclass \u00a4 Bases: SongList Saved class for handling the saved tracks from user library. create_basic_list ( url = 'saved' ) classmethod \u00a4 Create a basic list with only the required metadata and urls. Returns \u00a4 The Saved object. Source code in spotdl/types/saved.py 85 86 87 88 89 90 91 92 93 94 95 96 97 @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = []) from_url ( url = 'saved' ) classmethod \u00a4 Loads saved tracks from Spotify. Will throw an exception if users is not logged in. Source code in spotdl/types/saved.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) get_metadata ( url = 'saved' ) staticmethod \u00a4 Returns metadata for a saved list. Arguments \u00a4 url: Not required, but used to match the signature of the other get_metadata methods. Source code in spotdl/types/saved.py 99 100 101 102 103 104 105 106 107 108 @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str , Any ]: \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url } get_urls ( _ = 'saved' ) staticmethod \u00a4 Returns a list of urls of all saved tracks. Arguments \u00a4 _: not required, but used to match the signature of the other get_urls methods. Returns \u00a4 A list of urls. Source code in spotdl/types/saved.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ]: \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type: ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ]: response = spotify_client . next ( saved_tracks_response ) # response is wrong, break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ]) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track [ \"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {}) . get ( \"id\" ) ] SavedError \u00a4 Bases: Exception Base class for all exceptions related to saved tracks.","title":"saved"},{"location":"reference/types/saved/#spotdl.types.saved.Saved","text":"Bases: SongList Saved class for handling the saved tracks from user library.","title":"Saved"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.create_basic_list","text":"Create a basic list with only the required metadata and urls.","title":"create_basic_list()"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.create_basic_list--returns","text":"The Saved object. Source code in spotdl/types/saved.py 85 86 87 88 89 90 91 92 93 94 95 96 97 @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [])","title":"Returns"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.from_url","text":"Loads saved tracks from Spotify. Will throw an exception if users is not logged in. Source code in spotdl/types/saved.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , )","title":"from_url()"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata","text":"Returns metadata for a saved list.","title":"get_metadata()"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata--arguments","text":"url: Not required, but used to match the signature of the other get_metadata methods. Source code in spotdl/types/saved.py 99 100 101 102 103 104 105 106 107 108 @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str , Any ]: \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url }","title":"Arguments"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_urls","text":"Returns a list of urls of all saved tracks.","title":"get_urls()"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_urls--arguments","text":"_: not required, but used to match the signature of the other get_urls methods.","title":"Arguments"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_urls--returns","text":"A list of urls. Source code in spotdl/types/saved.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ]: \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type: ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ]: response = spotify_client . next ( saved_tracks_response ) # response is wrong, break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ]) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track [ \"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {}) . get ( \"id\" ) ]","title":"Returns"},{"location":"reference/types/saved/#spotdl.types.saved.SavedError","text":"Bases: Exception Base class for all exceptions related to saved tracks.","title":"SavedError"},{"location":"reference/types/song/","text":"Song module that hold the Song and SongList classes. Song dataclass \u00a4 Song class. Contains all the information about a song. display_name () property \u00a4 Returns a display name for the song. Returns \u00a4 The display name. Source code in spotdl/types/song.py 170 171 172 173 174 175 176 177 178 179 @property def display_name ( self ) -> str : \"\"\" Returns a display name for the song. ### Returns - The display name. \"\"\" return f \" { self . artist } - { self . name } \" from_data_dump ( data ) classmethod \u00a4 Create a Song object from a data dump. Arguments \u00a4 data: The data dump. Returns \u00a4 The Song object. Source code in spotdl/types/song.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict ) from_dict ( data ) classmethod \u00a4 Create a Song object from a dictionary. Arguments \u00a4 data: The dictionary. Returns \u00a4 The Song object. Source code in spotdl/types/song.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data ) from_search_term ( search_term ) classmethod \u00a4 Creates a list of Song objects from a search term. Arguments \u00a4 search_term: The search term to use. Returns \u00a4 The Song object. Source code in spotdl/types/song.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] ) from_url ( url ) classmethod \u00a4 Creates a Song object from a URL. Arguments \u00a4 url: The URL of the song. Returns \u00a4 The Song object. Source code in spotdl/types/song.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: { url } \" ) # query spotify for song, artist, album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str , Any ] = spotify_client . artist ( primary_artist_id ) # type: ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str , Any ] = spotify_client . album ( album_id ) # type: ignore # create song object return cls ( name = raw_track_meta [ \"name\" ], artists = [ artist [ \"name\" ] for artist in raw_track_meta [ \"artists\" ]], artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ], album_name = raw_album_meta [ \"name\" ], album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ], copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ], disc_number = raw_track_meta [ \"disc_number\" ], disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ - 1 ][ \"disc_number\" ]), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][: 4 ]), date = raw_album_meta [ \"release_date\" ], track_number = raw_track_meta [ \"track_number\" ], tracks_count = raw_album_meta [ \"total_tracks\" ], isrc = raw_track_meta . get ( \"external_ids\" , {}) . get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ], explicit = raw_track_meta [ \"explicit\" ], publisher = raw_album_meta [ \"label\" ], url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ], cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ] if raw_album_meta [ \"images\" ] else None , ) json () property \u00a4 Returns a dictionary of the song's data. Returns \u00a4 The dictionary. Source code in spotdl/types/song.py 181 182 183 184 185 186 187 188 189 190 @property def json ( self ) -> Dict [ str , Any ]: \"\"\" Returns a dictionary of the song's data. ### Returns - The dictionary. \"\"\" return asdict ( self ) SongError \u00a4 Bases: Exception Base class for all exceptions related to songs. SongList dataclass \u00a4 SongList class. Base class for all other song lists subclasses. create_basic_list ( url ) classmethod \u00a4 Create a basic list with only the required metadata and urls. Arguments \u00a4 url: The url of the list. Returns \u00a4 The SongList object. Source code in spotdl/types/song.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @classmethod def create_basic_list ( cls , url : str ): \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = []) from_url ( url ) classmethod \u00a4 Initialize a SongList object from a URL. Arguments \u00a4 url: The URL of the list. Source code in spotdl/types/song.py 232 233 234 235 236 237 238 239 240 241 @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError get_metadata ( url ) staticmethod \u00a4 Get metadata for list. Arguments \u00a4 url: The URL of the list. Returns \u00a4 The metadata. Source code in spotdl/types/song.py 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError get_urls ( url ) staticmethod \u00a4 Get urls for all songs in url. Arguments \u00a4 url: The URL of the list. Returns \u00a4 The list of urls. Source code in spotdl/types/song.py 243 244 245 246 247 248 249 250 251 252 253 254 255 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError length () property \u00a4 Get list length (number of songs). Returns \u00a4 The list length. Source code in spotdl/types/song.py 204 205 206 207 208 209 210 211 212 213 @property def length ( self ) -> int : \"\"\" Get list length (number of songs). ### Returns - The list length. \"\"\" return len ( self . songs )","title":"song"},{"location":"reference/types/song/#spotdl.types.song.Song","text":"Song class. Contains all the information about a song.","title":"Song"},{"location":"reference/types/song/#spotdl.types.song.Song.display_name","text":"Returns a display name for the song.","title":"display_name()"},{"location":"reference/types/song/#spotdl.types.song.Song.display_name--returns","text":"The display name. Source code in spotdl/types/song.py 170 171 172 173 174 175 176 177 178 179 @property def display_name ( self ) -> str : \"\"\" Returns a display name for the song. ### Returns - The display name. \"\"\" return f \" { self . artist } - { self . name } \"","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump","text":"Create a Song object from a data dump.","title":"from_data_dump()"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump--arguments","text":"data: The data dump.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump--returns","text":"The Song object. Source code in spotdl/types/song.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict )","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict","text":"Create a Song object from a dictionary.","title":"from_dict()"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict--arguments","text":"data: The dictionary.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict--returns","text":"The Song object. Source code in spotdl/types/song.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data )","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term","text":"Creates a list of Song objects from a search term.","title":"from_search_term()"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term--arguments","text":"search_term: The search term to use.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term--returns","text":"The Song object. Source code in spotdl/types/song.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] )","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url","text":"Creates a Song object from a URL.","title":"from_url()"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url--arguments","text":"url: The URL of the song.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url--returns","text":"The Song object. Source code in spotdl/types/song.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: { url } \" ) # query spotify for song, artist, album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str , Any ] = spotify_client . artist ( primary_artist_id ) # type: ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str , Any ] = spotify_client . album ( album_id ) # type: ignore # create song object return cls ( name = raw_track_meta [ \"name\" ], artists = [ artist [ \"name\" ] for artist in raw_track_meta [ \"artists\" ]], artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ], album_name = raw_album_meta [ \"name\" ], album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ], copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ], disc_number = raw_track_meta [ \"disc_number\" ], disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ - 1 ][ \"disc_number\" ]), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][: 4 ]), date = raw_album_meta [ \"release_date\" ], track_number = raw_track_meta [ \"track_number\" ], tracks_count = raw_album_meta [ \"total_tracks\" ], isrc = raw_track_meta . get ( \"external_ids\" , {}) . get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ], explicit = raw_track_meta [ \"explicit\" ], publisher = raw_album_meta [ \"label\" ], url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ], cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ] if raw_album_meta [ \"images\" ] else None , )","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.Song.json","text":"Returns a dictionary of the song's data.","title":"json()"},{"location":"reference/types/song/#spotdl.types.song.Song.json--returns","text":"The dictionary. Source code in spotdl/types/song.py 181 182 183 184 185 186 187 188 189 190 @property def json ( self ) -> Dict [ str , Any ]: \"\"\" Returns a dictionary of the song's data. ### Returns - The dictionary. \"\"\" return asdict ( self )","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.SongError","text":"Bases: Exception Base class for all exceptions related to songs.","title":"SongError"},{"location":"reference/types/song/#spotdl.types.song.SongList","text":"SongList class. Base class for all other song lists subclasses.","title":"SongList"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_list","text":"Create a basic list with only the required metadata and urls.","title":"create_basic_list()"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_list--arguments","text":"url: The url of the list.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_list--returns","text":"The SongList object. Source code in spotdl/types/song.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @classmethod def create_basic_list ( cls , url : str ): \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [])","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url","text":"Initialize a SongList object from a URL.","title":"from_url()"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url--arguments","text":"url: The URL of the list. Source code in spotdl/types/song.py 232 233 234 235 236 237 238 239 240 241 @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata","text":"Get metadata for list.","title":"get_metadata()"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata--arguments","text":"url: The URL of the list.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata--returns","text":"The metadata. Source code in spotdl/types/song.py 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_urls","text":"Get urls for all songs in url.","title":"get_urls()"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_urls--arguments","text":"url: The URL of the list.","title":"Arguments"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_urls--returns","text":"The list of urls. Source code in spotdl/types/song.py 243 244 245 246 247 248 249 250 251 252 253 254 255 @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/types/song/#spotdl.types.song.SongList.length","text":"Get list length (number of songs).","title":"length()"},{"location":"reference/types/song/#spotdl.types.song.SongList.length--returns","text":"The list length. Source code in spotdl/types/song.py 204 205 206 207 208 209 210 211 212 213 @property def length ( self ) -> int : \"\"\" Get list length (number of songs). ### Returns - The list length. \"\"\" return len ( self . songs )","title":"Returns"},{"location":"reference/utils/","text":"Utility functions for spotdl. These functions are used in every stage of the download process.","title":"utils"},{"location":"reference/utils/arguments/","text":"Module that handles the command line arguments. SmartFormatter \u00a4 Bases: argparse . HelpFormatter Class that overrides the default help formatter. parse_arguments () \u00a4 Parse arguments from the command line. Returns \u00a4 A Namespace object containing the parsed arguments. Source code in spotdl/utils/arguments.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def parse_arguments () -> Namespace : \"\"\" Parse arguments from the command line. ### Returns - A Namespace object containing the parsed arguments. \"\"\" # Initialize argument parser parser = ArgumentParser ( prog = \"spotdl\" , description = \"Download your Spotify playlists and songs along with album art and metadata\" , formatter_class = SmartFormatter , epilog = ( \"For more information, visit https://spotdl.github.io/spotify-downloader/ \" \"or join our Discord server: https://discord.com/invite/xCa23pwJWY\" ), ) # Parse main options main_options = parser . add_argument_group ( \"Main options\" ) parse_main_options ( main_options ) # Parse spotify options spotify_options = parser . add_argument_group ( \"Spotify options\" ) parse_spotify_options ( spotify_options ) # Parse ffmpeg options ffmpeg_options = parser . add_argument_group ( \"FFmpeg options\" ) parse_ffmpeg_options ( ffmpeg_options ) # Parse output options output_options = parser . add_argument_group ( \"Output options\" ) parse_output_options ( output_options ) # Parse misc options misc_options = parser . add_argument_group ( \"Misc options\" ) parse_misc_options ( misc_options ) # Parse other options other_options = parser . add_argument_group ( \"Other options\" ) parse_other_options ( other_options ) return parser . parse_args () parse_ffmpeg_options ( parser ) \u00a4 Parse ffmpeg options from the command line. Arguments \u00a4 parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def parse_ffmpeg_options ( parser : _ArgumentGroup ): \"\"\" Parse ffmpeg options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add ffmpeg executable argument parser . add_argument ( \"--ffmpeg\" , help = \"The ffmpeg executable to use.\" , ) # Add search threads argument parser . add_argument ( \"--threads\" , type = int , help = \"The number of threads to use when downloading songs.\" , ) # Add constant bit rate argument parser . add_argument ( \"--bitrate\" , choices = [ \"8k\" , \"16k\" , \"24k\" , \"32k\" , \"40k\" , \"48k\" , \"64k\" , \"80k\" , \"96k\" , \"112k\" , \"128k\" , \"160k\" , \"192k\" , \"224k\" , \"256k\" , \"320k\" , ], type = str . lower , help = \"The constant bitrate to use for the output file.\" , ) # Additional ffmpeg arguments parser . add_argument ( \"--ffmpeg-args\" , type = str , help = \"Additional ffmpeg arguments passed as a string.\" , ) parse_main_options ( parser ) \u00a4 Parse main options from the command line. Arguments \u00a4 parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def parse_main_options ( parser : _ArgumentGroup ): \"\"\" Parse main options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add operation argument operation = parser . add_argument ( \"operation\" , choices = OPERATIONS , help = ( \"N|The operation to perform. \\n \" \"download: Download the songs to the disk and embed metadata. \\n \" \"save: Saves the songs metadata to a file for further use. \\n \" \"web: Starts a web interface to simplify the download process. \\n \" \"sync: removes songs that are no longer present, downloads new ones \\n \" ), ) # Add query argument query = parser . add_argument ( \"query\" , nargs = \"+\" , type = str , help = ( \"Spotify URL for a song/playlist/album/artist/etc. to download.\" \"For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL'\" ), ) try : is_web = sys . argv [ 1 ] == \"web\" except IndexError : is_web = False is_frozen = getattr ( sys , \"frozen\" , False ) # If the program is frozen, we and user didn't pass any arguments, # or if the user is using the web interface, we don't need to parse # the query if ( is_frozen and len ( sys . argv ) < 2 ) or ( len ( sys . argv ) > 1 and is_web ): # If we are running the web interface # or we are in the frozen env and not running web interface # don't remove the operation from the arg parser if not is_web or ( is_frozen and not is_web ): parser . _remove_action ( operation ) # pylint: disable=protected-access parser . _remove_action ( query ) # pylint: disable=protected-access # Audio provider argument parser . add_argument ( \"--audio\" , dest = \"audio_providers\" , nargs = \"*\" , choices = AUDIO_PROVIDERS , help = \"The audio provider to use. You can provide more than one for fallback.\" , ) # Lyrics provider argument parser . add_argument ( \"--lyrics\" , dest = \"lyrics_providers\" , nargs = \"*\" , choices = LYRICS_PROVIDERS . keys (), help = \"The lyrics provider to use. You can provide more than one for fallback.\" , ) # Add config argument parser . add_argument ( \"--config\" , action = \"store_true\" , help = ( \"Use the config file to download songs. \" \"It's located under C: \\\\ Users \\\\ user \\\\ .spotdl \\\\ config.json \" \"or ~/.spotdl/config.json under linux\" ), ) # Add search query argument parser . add_argument ( \"--search-query\" , help = f \"The search query to use, available variables: { ', ' . join ( VARS ) } \" , ) # Add don't filter results argument parser . add_argument ( \"--dont-filter-results\" , dest = \"filter_results\" , help = \"Disable filtering results.\" , ) parse_misc_options ( parser ) \u00a4 Parse misc options from the command line. Arguments \u00a4 parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def parse_misc_options ( parser : _ArgumentGroup ): \"\"\" Parse misc options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add verbose argument parser . add_argument ( \"--log-level\" , choices = NAME_TO_LEVEL . keys (), help = \"Select log level.\" , ) # Add simple tui argument parser . add_argument ( \"--simple-tui\" , action = \"store_const\" , const = True , help = \"Use a simple tui.\" , ) # Add headless argument parser . add_argument ( \"--headless\" , action = \"store_const\" , const = True , help = \"Run in headless mode.\" , ) parse_other_options ( parser ) \u00a4 Parse other options from the command line. Arguments \u00a4 parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def parse_other_options ( parser : _ArgumentGroup ): \"\"\" Parse other options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" parser . add_argument ( \"--download-ffmpeg\" , action = \"store_true\" , help = \"Download ffmpeg to spotdl directory.\" , ) parser . add_argument ( \"--generate-config\" , action = \"store_true\" , help = \"Generate a config file. This will overwrite current config if present.\" , ) parser . add_argument ( \"--check-for-updates\" , action = \"store_true\" , help = \"Check for new version.\" ) parser . add_argument ( \"--profile\" , action = \"store_true\" , help = \"Run in profile mode. Useful for debugging.\" , ) parser . add_argument ( \"--version\" , \"-v\" , action = \"version\" , help = \"Show the version number and exit.\" , version = _version . __version__ , ) parse_output_options ( parser ) \u00a4 Parse output options from the command line. Arguments \u00a4 parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def parse_output_options ( parser : _ArgumentGroup ): \"\"\" Parse output options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add output format argument parser . add_argument ( \"--format\" , choices = FFMPEG_FORMATS . keys (), help = \"The format to download the song in.\" , ) # Add save file argument parser . add_argument ( \"--save-file\" , type = str , help = ( \"The file to save/load the songs data from/to. \" \"It has to end with .spotdl. \" \"If combined with the download operation, it will save the songs data to the file. \" \"Required for save/preload/sync\" ), required = len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ \"save\" ], ) # Add preload argument parser . add_argument ( \"--preload\" , action = \"store_const\" , const = True , help = \"Preload the download url to speed up the download process.\" , ) # Add name format argument parser . add_argument ( \"--output\" , type = str , help = f \"Specify the downloaded file name format, available variables: { ', ' . join ( VARS ) } \" , ) # Add m3u argument parser . add_argument ( \"--m3u\" , type = str , help = \"Name of the m3u file to save the songs to.\" , ) # Add overwrite argument parser . add_argument ( \"--overwrite\" , choices = { \"force\" , \"skip\" }, help = \"Overwrite existing files.\" , ) # Option to restrict filenames for easier handling in the shell parser . add_argument ( \"--restrict\" , action = \"store_const\" , const = True , help = \"Restrict filenames to ASCII only\" , ) # Option to print errors on exit, useful for long playlist parser . add_argument ( \"--print-errors\" , action = \"store_const\" , const = True , help = \"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\" , ) # Option to use sponsor block parser . add_argument ( \"--sponsor-block\" , action = \"store_const\" , const = True , help = \"Use the sponsor block to download songs from yt/ytm.\" , ) parse_spotify_options ( parser ) \u00a4 Parse spotify options from the command line. Arguments \u00a4 parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def parse_spotify_options ( parser : _ArgumentGroup ): \"\"\" Parse spotify options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add login argument parser . add_argument ( \"--user-auth\" , help = \"Login to Spotify using OAuth.\" , ) # Add client id argument parser . add_argument ( \"--client-id\" , help = \"The client id to use when logging in to Spotify.\" , ) # Add client secret argument parser . add_argument ( \"--client-secret\" , help = \"The client secret to use when logging in to Spotify.\" , ) # Add auth token argument parser . add_argument ( \"--auth-token\" , help = \"The authorisation token to use directly to log in to Spotify.\" , ) # Add cache path argument parser . add_argument ( \"--cache-path\" , type = str , help = \"The path where spotipy cache file will be stored.\" , ) # Add no cache argument parser . add_argument ( \"--no-cache\" , action = \"store_const\" , const = True , help = \"Disable caching (both requests and token).\" , ) # Add cookie file argument parser . add_argument ( \"--cookie-file\" , help = \"Path to cookies file.\" , )","title":"arguments"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.SmartFormatter","text":"Bases: argparse . HelpFormatter Class that overrides the default help formatter.","title":"SmartFormatter"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments","text":"Parse arguments from the command line.","title":"parse_arguments()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments--returns","text":"A Namespace object containing the parsed arguments. Source code in spotdl/utils/arguments.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def parse_arguments () -> Namespace : \"\"\" Parse arguments from the command line. ### Returns - A Namespace object containing the parsed arguments. \"\"\" # Initialize argument parser parser = ArgumentParser ( prog = \"spotdl\" , description = \"Download your Spotify playlists and songs along with album art and metadata\" , formatter_class = SmartFormatter , epilog = ( \"For more information, visit https://spotdl.github.io/spotify-downloader/ \" \"or join our Discord server: https://discord.com/invite/xCa23pwJWY\" ), ) # Parse main options main_options = parser . add_argument_group ( \"Main options\" ) parse_main_options ( main_options ) # Parse spotify options spotify_options = parser . add_argument_group ( \"Spotify options\" ) parse_spotify_options ( spotify_options ) # Parse ffmpeg options ffmpeg_options = parser . add_argument_group ( \"FFmpeg options\" ) parse_ffmpeg_options ( ffmpeg_options ) # Parse output options output_options = parser . add_argument_group ( \"Output options\" ) parse_output_options ( output_options ) # Parse misc options misc_options = parser . add_argument_group ( \"Misc options\" ) parse_misc_options ( misc_options ) # Parse other options other_options = parser . add_argument_group ( \"Other options\" ) parse_other_options ( other_options ) return parser . parse_args ()","title":"Returns"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_ffmpeg_options","text":"Parse ffmpeg options from the command line.","title":"parse_ffmpeg_options()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_ffmpeg_options--arguments","text":"parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def parse_ffmpeg_options ( parser : _ArgumentGroup ): \"\"\" Parse ffmpeg options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add ffmpeg executable argument parser . add_argument ( \"--ffmpeg\" , help = \"The ffmpeg executable to use.\" , ) # Add search threads argument parser . add_argument ( \"--threads\" , type = int , help = \"The number of threads to use when downloading songs.\" , ) # Add constant bit rate argument parser . add_argument ( \"--bitrate\" , choices = [ \"8k\" , \"16k\" , \"24k\" , \"32k\" , \"40k\" , \"48k\" , \"64k\" , \"80k\" , \"96k\" , \"112k\" , \"128k\" , \"160k\" , \"192k\" , \"224k\" , \"256k\" , \"320k\" , ], type = str . lower , help = \"The constant bitrate to use for the output file.\" , ) # Additional ffmpeg arguments parser . add_argument ( \"--ffmpeg-args\" , type = str , help = \"Additional ffmpeg arguments passed as a string.\" , )","title":"Arguments"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_main_options","text":"Parse main options from the command line.","title":"parse_main_options()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_main_options--arguments","text":"parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def parse_main_options ( parser : _ArgumentGroup ): \"\"\" Parse main options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add operation argument operation = parser . add_argument ( \"operation\" , choices = OPERATIONS , help = ( \"N|The operation to perform. \\n \" \"download: Download the songs to the disk and embed metadata. \\n \" \"save: Saves the songs metadata to a file for further use. \\n \" \"web: Starts a web interface to simplify the download process. \\n \" \"sync: removes songs that are no longer present, downloads new ones \\n \" ), ) # Add query argument query = parser . add_argument ( \"query\" , nargs = \"+\" , type = str , help = ( \"Spotify URL for a song/playlist/album/artist/etc. to download.\" \"For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL'\" ), ) try : is_web = sys . argv [ 1 ] == \"web\" except IndexError : is_web = False is_frozen = getattr ( sys , \"frozen\" , False ) # If the program is frozen, we and user didn't pass any arguments, # or if the user is using the web interface, we don't need to parse # the query if ( is_frozen and len ( sys . argv ) < 2 ) or ( len ( sys . argv ) > 1 and is_web ): # If we are running the web interface # or we are in the frozen env and not running web interface # don't remove the operation from the arg parser if not is_web or ( is_frozen and not is_web ): parser . _remove_action ( operation ) # pylint: disable=protected-access parser . _remove_action ( query ) # pylint: disable=protected-access # Audio provider argument parser . add_argument ( \"--audio\" , dest = \"audio_providers\" , nargs = \"*\" , choices = AUDIO_PROVIDERS , help = \"The audio provider to use. You can provide more than one for fallback.\" , ) # Lyrics provider argument parser . add_argument ( \"--lyrics\" , dest = \"lyrics_providers\" , nargs = \"*\" , choices = LYRICS_PROVIDERS . keys (), help = \"The lyrics provider to use. You can provide more than one for fallback.\" , ) # Add config argument parser . add_argument ( \"--config\" , action = \"store_true\" , help = ( \"Use the config file to download songs. \" \"It's located under C: \\\\ Users \\\\ user \\\\ .spotdl \\\\ config.json \" \"or ~/.spotdl/config.json under linux\" ), ) # Add search query argument parser . add_argument ( \"--search-query\" , help = f \"The search query to use, available variables: { ', ' . join ( VARS ) } \" , ) # Add don't filter results argument parser . add_argument ( \"--dont-filter-results\" , dest = \"filter_results\" , help = \"Disable filtering results.\" , )","title":"Arguments"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_misc_options","text":"Parse misc options from the command line.","title":"parse_misc_options()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_misc_options--arguments","text":"parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def parse_misc_options ( parser : _ArgumentGroup ): \"\"\" Parse misc options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add verbose argument parser . add_argument ( \"--log-level\" , choices = NAME_TO_LEVEL . keys (), help = \"Select log level.\" , ) # Add simple tui argument parser . add_argument ( \"--simple-tui\" , action = \"store_const\" , const = True , help = \"Use a simple tui.\" , ) # Add headless argument parser . add_argument ( \"--headless\" , action = \"store_const\" , const = True , help = \"Run in headless mode.\" , )","title":"Arguments"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_other_options","text":"Parse other options from the command line.","title":"parse_other_options()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_other_options--arguments","text":"parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def parse_other_options ( parser : _ArgumentGroup ): \"\"\" Parse other options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" parser . add_argument ( \"--download-ffmpeg\" , action = \"store_true\" , help = \"Download ffmpeg to spotdl directory.\" , ) parser . add_argument ( \"--generate-config\" , action = \"store_true\" , help = \"Generate a config file. This will overwrite current config if present.\" , ) parser . add_argument ( \"--check-for-updates\" , action = \"store_true\" , help = \"Check for new version.\" ) parser . add_argument ( \"--profile\" , action = \"store_true\" , help = \"Run in profile mode. Useful for debugging.\" , ) parser . add_argument ( \"--version\" , \"-v\" , action = \"version\" , help = \"Show the version number and exit.\" , version = _version . __version__ , )","title":"Arguments"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_output_options","text":"Parse output options from the command line.","title":"parse_output_options()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_output_options--arguments","text":"parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def parse_output_options ( parser : _ArgumentGroup ): \"\"\" Parse output options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add output format argument parser . add_argument ( \"--format\" , choices = FFMPEG_FORMATS . keys (), help = \"The format to download the song in.\" , ) # Add save file argument parser . add_argument ( \"--save-file\" , type = str , help = ( \"The file to save/load the songs data from/to. \" \"It has to end with .spotdl. \" \"If combined with the download operation, it will save the songs data to the file. \" \"Required for save/preload/sync\" ), required = len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ \"save\" ], ) # Add preload argument parser . add_argument ( \"--preload\" , action = \"store_const\" , const = True , help = \"Preload the download url to speed up the download process.\" , ) # Add name format argument parser . add_argument ( \"--output\" , type = str , help = f \"Specify the downloaded file name format, available variables: { ', ' . join ( VARS ) } \" , ) # Add m3u argument parser . add_argument ( \"--m3u\" , type = str , help = \"Name of the m3u file to save the songs to.\" , ) # Add overwrite argument parser . add_argument ( \"--overwrite\" , choices = { \"force\" , \"skip\" }, help = \"Overwrite existing files.\" , ) # Option to restrict filenames for easier handling in the shell parser . add_argument ( \"--restrict\" , action = \"store_const\" , const = True , help = \"Restrict filenames to ASCII only\" , ) # Option to print errors on exit, useful for long playlist parser . add_argument ( \"--print-errors\" , action = \"store_const\" , const = True , help = \"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\" , ) # Option to use sponsor block parser . add_argument ( \"--sponsor-block\" , action = \"store_const\" , const = True , help = \"Use the sponsor block to download songs from yt/ytm.\" , )","title":"Arguments"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_spotify_options","text":"Parse spotify options from the command line.","title":"parse_spotify_options()"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_spotify_options--arguments","text":"parser: The argument parser to add the options to. Source code in spotdl/utils/arguments.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def parse_spotify_options ( parser : _ArgumentGroup ): \"\"\" Parse spotify options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add login argument parser . add_argument ( \"--user-auth\" , help = \"Login to Spotify using OAuth.\" , ) # Add client id argument parser . add_argument ( \"--client-id\" , help = \"The client id to use when logging in to Spotify.\" , ) # Add client secret argument parser . add_argument ( \"--client-secret\" , help = \"The client secret to use when logging in to Spotify.\" , ) # Add auth token argument parser . add_argument ( \"--auth-token\" , help = \"The authorisation token to use directly to log in to Spotify.\" , ) # Add cache path argument parser . add_argument ( \"--cache-path\" , type = str , help = \"The path where spotipy cache file will be stored.\" , ) # Add no cache argument parser . add_argument ( \"--no-cache\" , action = \"store_const\" , const = True , help = \"Disable caching (both requests and token).\" , ) # Add cookie file argument parser . add_argument ( \"--cookie-file\" , help = \"Path to cookies file.\" , )","title":"Arguments"},{"location":"reference/utils/config/","text":"Module related to managing reading and writing to the config file. Default config - spotdl.utils.config.DEFAULT_CONFIG ConfigError \u00a4 Bases: Exception Base class for all exceptions related to config. get_cache_path () \u00a4 Get the path to the cache folder. Returns \u00a4 The path to the spotipy cache file. Source code in spotdl/utils/config.py 49 50 51 52 53 54 55 56 57 def get_cache_path () -> Path : \"\"\" Get the path to the cache folder. ### Returns - The path to the spotipy cache file. \"\"\" return get_spotdl_path () / \".spotipy\" get_config () \u00a4 Get the config. Returns \u00a4 The dictionary with the config. Errors \u00a4 ConfigError: If the config file does not exist. Source code in spotdl/utils/config.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_config () -> Dict [ str , Any ]: \"\"\" Get the config. ### Returns - The dictionary with the config. ### Errors - ConfigError: If the config file does not exist. \"\"\" config_path = get_config_file () if not config_path . exists (): raise ConfigError ( \"Config file not found.\" \"Please run `spotdl --generate-config` to create a config file.\" ) with open ( config_path , \"r\" , encoding = \"utf-8\" ) as config_file : return json . load ( config_file ) get_config_file () \u00a4 Get config file path Returns \u00a4 The path to the config file. Source code in spotdl/utils/config.py 38 39 40 41 42 43 44 45 46 def get_config_file () -> Path : \"\"\" Get config file path ### Returns - The path to the config file. \"\"\" return get_spotdl_path () / \"config.json\" get_errors_path () \u00a4 Get the path to the errors folder. Returns \u00a4 The path to the errors folder. Notes \u00a4 If the errors directory does not exist, it will be created. Source code in spotdl/utils/config.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get_errors_path () -> Path : \"\"\" Get the path to the errors folder. ### Returns - The path to the errors folder. ### Notes - If the errors directory does not exist, it will be created. \"\"\" errors_path = get_spotdl_path () / \"errors\" if not errors_path . exists (): os . mkdir ( errors_path ) return errors_path get_spotdl_path () \u00a4 Get the path to the spotdl folder. Returns \u00a4 The path to the spotdl folder. Notes \u00a4 If the spotdl directory does not exist, it will be created. Source code in spotdl/utils/config.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def get_spotdl_path () -> Path : \"\"\" Get the path to the spotdl folder. ### Returns - The path to the spotdl folder. ### Notes - If the spotdl directory does not exist, it will be created. \"\"\" spotdl_path = Path ( os . path . expanduser ( \"~\" ), \".spotdl\" ) if not spotdl_path . exists (): os . mkdir ( spotdl_path ) return spotdl_path get_temp_path () \u00a4 Get the path to the temp folder. Returns \u00a4 The path to the temp folder. Source code in spotdl/utils/config.py 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_temp_path () -> Path : \"\"\" Get the path to the temp folder. ### Returns - The path to the temp folder. \"\"\" temp_path = get_spotdl_path () / \"temp\" if not temp_path . exists (): os . mkdir ( temp_path ) return temp_path","title":"config"},{"location":"reference/utils/config/#spotdl.utils.config.ConfigError","text":"Bases: Exception Base class for all exceptions related to config.","title":"ConfigError"},{"location":"reference/utils/config/#spotdl.utils.config.get_cache_path","text":"Get the path to the cache folder.","title":"get_cache_path()"},{"location":"reference/utils/config/#spotdl.utils.config.get_cache_path--returns","text":"The path to the spotipy cache file. Source code in spotdl/utils/config.py 49 50 51 52 53 54 55 56 57 def get_cache_path () -> Path : \"\"\" Get the path to the cache folder. ### Returns - The path to the spotipy cache file. \"\"\" return get_spotdl_path () / \".spotipy\"","title":"Returns"},{"location":"reference/utils/config/#spotdl.utils.config.get_config","text":"Get the config.","title":"get_config()"},{"location":"reference/utils/config/#spotdl.utils.config.get_config--returns","text":"The dictionary with the config.","title":"Returns"},{"location":"reference/utils/config/#spotdl.utils.config.get_config--errors","text":"ConfigError: If the config file does not exist. Source code in spotdl/utils/config.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_config () -> Dict [ str , Any ]: \"\"\" Get the config. ### Returns - The dictionary with the config. ### Errors - ConfigError: If the config file does not exist. \"\"\" config_path = get_config_file () if not config_path . exists (): raise ConfigError ( \"Config file not found.\" \"Please run `spotdl --generate-config` to create a config file.\" ) with open ( config_path , \"r\" , encoding = \"utf-8\" ) as config_file : return json . load ( config_file )","title":"Errors"},{"location":"reference/utils/config/#spotdl.utils.config.get_config_file","text":"Get config file path","title":"get_config_file()"},{"location":"reference/utils/config/#spotdl.utils.config.get_config_file--returns","text":"The path to the config file. Source code in spotdl/utils/config.py 38 39 40 41 42 43 44 45 46 def get_config_file () -> Path : \"\"\" Get config file path ### Returns - The path to the config file. \"\"\" return get_spotdl_path () / \"config.json\"","title":"Returns"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path","text":"Get the path to the errors folder.","title":"get_errors_path()"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path--returns","text":"The path to the errors folder.","title":"Returns"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path--notes","text":"If the errors directory does not exist, it will be created. Source code in spotdl/utils/config.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get_errors_path () -> Path : \"\"\" Get the path to the errors folder. ### Returns - The path to the errors folder. ### Notes - If the errors directory does not exist, it will be created. \"\"\" errors_path = get_spotdl_path () / \"errors\" if not errors_path . exists (): os . mkdir ( errors_path ) return errors_path","title":"Notes"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path","text":"Get the path to the spotdl folder.","title":"get_spotdl_path()"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path--returns","text":"The path to the spotdl folder.","title":"Returns"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path--notes","text":"If the spotdl directory does not exist, it will be created. Source code in spotdl/utils/config.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def get_spotdl_path () -> Path : \"\"\" Get the path to the spotdl folder. ### Returns - The path to the spotdl folder. ### Notes - If the spotdl directory does not exist, it will be created. \"\"\" spotdl_path = Path ( os . path . expanduser ( \"~\" ), \".spotdl\" ) if not spotdl_path . exists (): os . mkdir ( spotdl_path ) return spotdl_path","title":"Notes"},{"location":"reference/utils/config/#spotdl.utils.config.get_temp_path","text":"Get the path to the temp folder.","title":"get_temp_path()"},{"location":"reference/utils/config/#spotdl.utils.config.get_temp_path--returns","text":"The path to the temp folder. Source code in spotdl/utils/config.py 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_temp_path () -> Path : \"\"\" Get the path to the temp folder. ### Returns - The path to the temp folder. \"\"\" temp_path = get_spotdl_path () / \"temp\" if not temp_path . exists (): os . mkdir ( temp_path ) return temp_path","title":"Returns"},{"location":"reference/utils/ffmpeg/","text":"Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found. FFmpegError \u00a4 Bases: Exception Base class for all exceptions related to FFmpeg. convert ( input_file , output_file , ffmpeg = 'ffmpeg' , output_format = 'mp3' , bitrate = None , ffmpeg_args = None , progress_handler = None ) \u00a4 Convert the input file to the output file synchronously with progress handler. Arguments \u00a4 input_file: Path to input file or tuple of (url, file_format). output_file: Path to output file. ffmpeg: ffmpeg executable to use. output_format: output format. bitrate: constant bitrate. ffmpeg_args: ffmpeg arguments. progress_handler: progress handler, has to accept an integer as argument. Returns \u00a4 Tuple of conversion status and error dictionary. Notes \u00a4 Make sure to check if ffmpeg is installed before calling this function. Source code in spotdl/utils/ffmpeg.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def convert ( input_file : Union [ Path , Tuple [ str , str ]], output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable [[ int ], None ]] = None , ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]]: \"\"\" Convert the input file to the output file synchronously with progress handler. ### Arguments - input_file: Path to input file or tuple of (url, file_format). - output_file: Path to output file. - ffmpeg: ffmpeg executable to use. - output_format: output format. - bitrate: constant bitrate. - ffmpeg_args: ffmpeg arguments. - progress_handler: progress handler, has to accept an integer as argument. ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # -i is the input file arguments : List [ str ] = [ \"-nostdin\" , \"-y\" , \"-i\" , str ( input_file . resolve ()) if isinstance ( input_file , Path ) else input_file [ 0 ], \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , \"-progress\" , \"-\" , \"-nostats\" , ] file_format = ( str ( input_file . suffix ) . split ( \".\" )[ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # -c:a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ([ \"-c:a\" , \"libopus\" ]) else : if ( ( output_format == \"opus\" and file_format == \"opus\" ) or ( output_format == \"m4a\" and file_format == \"m4a\" ) and not ( bitrate or ffmpeg_args ) ): # Copy the audio stream to the output file arguments . extend ([ \"-vn\" , \"-c:a\" , \"copy\" ]) else : arguments . extend ( FFMPEG_FORMATS [ output_format ]) # Add constant bitrate if specified if bitrate : arguments . extend ([ \"-b:a\" , bitrate ]) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg with subprocess . Popen ( [ ffmpeg , * arguments ], stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = False , ) as process : if not progress_handler : # Wait for process to finish proc_out = process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf-8 message = b \"\" . join ([ out for out in proc_out if out ]) . decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } return True , None progress_handler ( 0 ) stderr_buffer = [] total_dur = None stderr : str = \"\" while True : if process . stdout is None : continue stderr_line = ( process . stdout . readline () . decode ( \"utf-8\" , errors = \"replace\" ) . strip () ) if stderr_line == \"\" and process . poll () is not None : break stderr_buffer . append ( stderr_line . strip ()) stderr = \" \\n \" . join ( stderr_buffer ) total_dur_match = DUR_REGEX . search ( stderr_line ) if total_dur is None and total_dur_match : total_dur = to_ms ( ** total_dur_match . groupdict ()) # type: ignore continue if total_dur : progress_time = TIME_REGEX . search ( stderr_line ) if progress_time : elapsed_time = to_ms ( ** progress_time . groupdict ()) # type: ignore progress_handler ( int ( elapsed_time / total_dur * 100 )) # type: ignore if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) return False , { \"error\" : stderr , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } progress_handler ( 100 ) return True , None download_ffmpeg () \u00a4 Download ffmpeg binary to spotdl directory. Returns \u00a4 Path to ffmpeg binary. Notes \u00a4 ffmpeg is downloaded from github releases for current platform and architecture. executable permission is set for ffmpeg binary. Source code in spotdl/utils/ffmpeg.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def download_ffmpeg () -> Path : \"\"\" Download ffmpeg binary to spotdl directory. ### Returns - Path to ffmpeg binary. ### Notes - ffmpeg is downloaded from github releases for current platform and architecture. - executable permission is set for ffmpeg binary. \"\"\" os_name = platform . system () . lower () os_arch = platform . machine () . lower () ffmpeg_url = FFMPEG_URLS . get ( os_name , {}) . get ( os_arch ) ffmpeg_path = Path ( os . path . join ( get_spotdl_path (), \"ffmpeg\" + ( \".exe\" if os_name == \"windows\" else \"\" ) ) ) if ffmpeg_url is None : raise FFmpegError ( \"FFmpeg binary is not available for your system.\" ) # Download binary and save it to a file in spotdl directory ffmpeg_binary = requests . get ( ffmpeg_url , allow_redirects = True ) . content with open ( ffmpeg_path , \"wb\" ) as ffmpeg_file : ffmpeg_file . write ( ffmpeg_binary ) # Set executable permission on linux and mac if os_name in [ \"linux\" , \"darwin\" ]: ffmpeg_path . chmod ( ffmpeg_path . stat () . st_mode | stat . S_IEXEC ) return ffmpeg_path get_ffmpeg_path () \u00a4 Get path to global ffmpeg binary or a local ffmpeg binary. Returns \u00a4 Path to ffmpeg binary or None if not found. Source code in spotdl/utils/ffmpeg.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_ffmpeg_path () -> Optional [ Path ]: \"\"\" Get path to global ffmpeg binary or a local ffmpeg binary. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" # Check if ffmpeg is installed global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg : return Path ( global_ffmpeg ) # Get local ffmpeg path return get_local_ffmpeg () get_ffmpeg_version ( ffmpeg = 'ffmpeg' ) \u00a4 Get ffmpeg version. Arguments \u00a4 ffmpeg: ffmpeg executable to check Returns \u00a4 Tuple of optional version and optional year. Errors \u00a4 FFmpegError if ffmpeg is not installed. FFmpegError if ffmpeg version is not found. Source code in spotdl/utils/ffmpeg.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_ffmpeg_version ( ffmpeg : str = \"ffmpeg\" ) -> Tuple [ Optional [ float ], Optional [ int ]]: \"\"\" Get ffmpeg version. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - Tuple of optional version and optional year. ### Errors - FFmpegError if ffmpeg is not installed. - FFmpegError if ffmpeg version is not found. \"\"\" # Check if ffmpeg is installed if not is_ffmpeg_installed ( ffmpeg ): if ffmpeg == \"ffmpeg\" : raise FFmpegError ( \"ffmpeg is not installed.\" ) raise FFmpegError ( f \" { ffmpeg } is not a valid ffmpeg executable.\" ) with subprocess . Popen ( [ ffmpeg , \"-version\" ], stdout = subprocess . PIPE , stderr = subprocess . PIPE , encoding = \"utf-8\" , ) as process : output = \"\" . join ( process . communicate ()) # Search for version and build year in output version_result = VERSION_REGEX . search ( output ) year_result = YEAR_REGEX . search ( output ) build_year = None version = None if version_result is not None : # remove all non numeric characters from string example: n4.3 version_str = re . sub ( r \"[a-zA-Z]\" , \"\" , version_result . group ( 0 )) # parse version string to float version = float ( version_str ) if version_str else None if year_result is not None : # get build years from string example: Copyright (c) 2019-2020 build_years = [ int ( re . sub ( r \"[^0-9]\" , \"\" , year ) ) # remove all non numeric characters from string for year in year_result . group ( 0 ) . split ( \"-\" ) # split string into list of years ] # get the highest build year build_year = max ( build_years ) return ( version , build_year ) get_local_ffmpeg () \u00a4 Get local ffmpeg binary path. Returns \u00a4 Path to ffmpeg binary or None if not found. Source code in spotdl/utils/ffmpeg.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def get_local_ffmpeg () -> Optional [ Path ]: \"\"\" Get local ffmpeg binary path. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" ffmpeg_path = Path ( get_spotdl_path ()) / ( \"ffmpeg\" + ( \".exe\" if platform . system () == \"Windows\" else \"\" ) ) if ffmpeg_path . is_file (): return ffmpeg_path return None is_ffmpeg_installed ( ffmpeg = 'ffmpeg' ) \u00a4 Check if ffmpeg is installed. Arguments \u00a4 ffmpeg: ffmpeg executable to check Returns \u00a4 True if ffmpeg is installed, False otherwise. Source code in spotdl/utils/ffmpeg.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def is_ffmpeg_installed ( ffmpeg : str = \"ffmpeg\" ) -> bool : \"\"\" Check if ffmpeg is installed. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - True if ffmpeg is installed, False otherwise. \"\"\" if ffmpeg == \"ffmpeg\" : global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg is None : ffmpeg_path = get_ffmpeg_path () else : ffmpeg_path = Path ( global_ffmpeg ) else : ffmpeg_path = Path ( ffmpeg ) if ffmpeg_path is None : return False # else check if path to ffmpeg is valid # and if ffmpeg has the correct access rights return ffmpeg_path . exists () and os . access ( ffmpeg_path , os . X_OK )","title":"ffmpeg"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.FFmpegError","text":"Bases: Exception Base class for all exceptions related to FFmpeg.","title":"FFmpegError"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert","text":"Convert the input file to the output file synchronously with progress handler.","title":"convert()"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--arguments","text":"input_file: Path to input file or tuple of (url, file_format). output_file: Path to output file. ffmpeg: ffmpeg executable to use. output_format: output format. bitrate: constant bitrate. ffmpeg_args: ffmpeg arguments. progress_handler: progress handler, has to accept an integer as argument.","title":"Arguments"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--returns","text":"Tuple of conversion status and error dictionary.","title":"Returns"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--notes","text":"Make sure to check if ffmpeg is installed before calling this function. Source code in spotdl/utils/ffmpeg.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def convert ( input_file : Union [ Path , Tuple [ str , str ]], output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable [[ int ], None ]] = None , ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]]: \"\"\" Convert the input file to the output file synchronously with progress handler. ### Arguments - input_file: Path to input file or tuple of (url, file_format). - output_file: Path to output file. - ffmpeg: ffmpeg executable to use. - output_format: output format. - bitrate: constant bitrate. - ffmpeg_args: ffmpeg arguments. - progress_handler: progress handler, has to accept an integer as argument. ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # -i is the input file arguments : List [ str ] = [ \"-nostdin\" , \"-y\" , \"-i\" , str ( input_file . resolve ()) if isinstance ( input_file , Path ) else input_file [ 0 ], \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , \"-progress\" , \"-\" , \"-nostats\" , ] file_format = ( str ( input_file . suffix ) . split ( \".\" )[ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # -c:a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ([ \"-c:a\" , \"libopus\" ]) else : if ( ( output_format == \"opus\" and file_format == \"opus\" ) or ( output_format == \"m4a\" and file_format == \"m4a\" ) and not ( bitrate or ffmpeg_args ) ): # Copy the audio stream to the output file arguments . extend ([ \"-vn\" , \"-c:a\" , \"copy\" ]) else : arguments . extend ( FFMPEG_FORMATS [ output_format ]) # Add constant bitrate if specified if bitrate : arguments . extend ([ \"-b:a\" , bitrate ]) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg with subprocess . Popen ( [ ffmpeg , * arguments ], stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = False , ) as process : if not progress_handler : # Wait for process to finish proc_out = process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf-8 message = b \"\" . join ([ out for out in proc_out if out ]) . decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } return True , None progress_handler ( 0 ) stderr_buffer = [] total_dur = None stderr : str = \"\" while True : if process . stdout is None : continue stderr_line = ( process . stdout . readline () . decode ( \"utf-8\" , errors = \"replace\" ) . strip () ) if stderr_line == \"\" and process . poll () is not None : break stderr_buffer . append ( stderr_line . strip ()) stderr = \" \\n \" . join ( stderr_buffer ) total_dur_match = DUR_REGEX . search ( stderr_line ) if total_dur is None and total_dur_match : total_dur = to_ms ( ** total_dur_match . groupdict ()) # type: ignore continue if total_dur : progress_time = TIME_REGEX . search ( stderr_line ) if progress_time : elapsed_time = to_ms ( ** progress_time . groupdict ()) # type: ignore progress_handler ( int ( elapsed_time / total_dur * 100 )) # type: ignore if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) return False , { \"error\" : stderr , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } progress_handler ( 100 ) return True , None","title":"Notes"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg","text":"Download ffmpeg binary to spotdl directory.","title":"download_ffmpeg()"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg--returns","text":"Path to ffmpeg binary.","title":"Returns"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg--notes","text":"ffmpeg is downloaded from github releases for current platform and architecture. executable permission is set for ffmpeg binary. Source code in spotdl/utils/ffmpeg.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def download_ffmpeg () -> Path : \"\"\" Download ffmpeg binary to spotdl directory. ### Returns - Path to ffmpeg binary. ### Notes - ffmpeg is downloaded from github releases for current platform and architecture. - executable permission is set for ffmpeg binary. \"\"\" os_name = platform . system () . lower () os_arch = platform . machine () . lower () ffmpeg_url = FFMPEG_URLS . get ( os_name , {}) . get ( os_arch ) ffmpeg_path = Path ( os . path . join ( get_spotdl_path (), \"ffmpeg\" + ( \".exe\" if os_name == \"windows\" else \"\" ) ) ) if ffmpeg_url is None : raise FFmpegError ( \"FFmpeg binary is not available for your system.\" ) # Download binary and save it to a file in spotdl directory ffmpeg_binary = requests . get ( ffmpeg_url , allow_redirects = True ) . content with open ( ffmpeg_path , \"wb\" ) as ffmpeg_file : ffmpeg_file . write ( ffmpeg_binary ) # Set executable permission on linux and mac if os_name in [ \"linux\" , \"darwin\" ]: ffmpeg_path . chmod ( ffmpeg_path . stat () . st_mode | stat . S_IEXEC ) return ffmpeg_path","title":"Notes"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_path","text":"Get path to global ffmpeg binary or a local ffmpeg binary.","title":"get_ffmpeg_path()"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_path--returns","text":"Path to ffmpeg binary or None if not found. Source code in spotdl/utils/ffmpeg.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_ffmpeg_path () -> Optional [ Path ]: \"\"\" Get path to global ffmpeg binary or a local ffmpeg binary. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" # Check if ffmpeg is installed global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg : return Path ( global_ffmpeg ) # Get local ffmpeg path return get_local_ffmpeg ()","title":"Returns"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version","text":"Get ffmpeg version.","title":"get_ffmpeg_version()"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--arguments","text":"ffmpeg: ffmpeg executable to check","title":"Arguments"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--returns","text":"Tuple of optional version and optional year.","title":"Returns"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--errors","text":"FFmpegError if ffmpeg is not installed. FFmpegError if ffmpeg version is not found. Source code in spotdl/utils/ffmpeg.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_ffmpeg_version ( ffmpeg : str = \"ffmpeg\" ) -> Tuple [ Optional [ float ], Optional [ int ]]: \"\"\" Get ffmpeg version. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - Tuple of optional version and optional year. ### Errors - FFmpegError if ffmpeg is not installed. - FFmpegError if ffmpeg version is not found. \"\"\" # Check if ffmpeg is installed if not is_ffmpeg_installed ( ffmpeg ): if ffmpeg == \"ffmpeg\" : raise FFmpegError ( \"ffmpeg is not installed.\" ) raise FFmpegError ( f \" { ffmpeg } is not a valid ffmpeg executable.\" ) with subprocess . Popen ( [ ffmpeg , \"-version\" ], stdout = subprocess . PIPE , stderr = subprocess . PIPE , encoding = \"utf-8\" , ) as process : output = \"\" . join ( process . communicate ()) # Search for version and build year in output version_result = VERSION_REGEX . search ( output ) year_result = YEAR_REGEX . search ( output ) build_year = None version = None if version_result is not None : # remove all non numeric characters from string example: n4.3 version_str = re . sub ( r \"[a-zA-Z]\" , \"\" , version_result . group ( 0 )) # parse version string to float version = float ( version_str ) if version_str else None if year_result is not None : # get build years from string example: Copyright (c) 2019-2020 build_years = [ int ( re . sub ( r \"[^0-9]\" , \"\" , year ) ) # remove all non numeric characters from string for year in year_result . group ( 0 ) . split ( \"-\" ) # split string into list of years ] # get the highest build year build_year = max ( build_years ) return ( version , build_year )","title":"Errors"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_local_ffmpeg","text":"Get local ffmpeg binary path.","title":"get_local_ffmpeg()"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_local_ffmpeg--returns","text":"Path to ffmpeg binary or None if not found. Source code in spotdl/utils/ffmpeg.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def get_local_ffmpeg () -> Optional [ Path ]: \"\"\" Get local ffmpeg binary path. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" ffmpeg_path = Path ( get_spotdl_path ()) / ( \"ffmpeg\" + ( \".exe\" if platform . system () == \"Windows\" else \"\" ) ) if ffmpeg_path . is_file (): return ffmpeg_path return None","title":"Returns"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed","text":"Check if ffmpeg is installed.","title":"is_ffmpeg_installed()"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed--arguments","text":"ffmpeg: ffmpeg executable to check","title":"Arguments"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed--returns","text":"True if ffmpeg is installed, False otherwise. Source code in spotdl/utils/ffmpeg.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def is_ffmpeg_installed ( ffmpeg : str = \"ffmpeg\" ) -> bool : \"\"\" Check if ffmpeg is installed. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - True if ffmpeg is installed, False otherwise. \"\"\" if ffmpeg == \"ffmpeg\" : global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg is None : ffmpeg_path = get_ffmpeg_path () else : ffmpeg_path = Path ( global_ffmpeg ) else : ffmpeg_path = Path ( ffmpeg ) if ffmpeg_path is None : return False # else check if path to ffmpeg is valid # and if ffmpeg has the correct access rights return ffmpeg_path . exists () and os . access ( ffmpeg_path , os . X_OK )","title":"Returns"},{"location":"reference/utils/formatter/","text":"Module for formatting songs into strings. Contains functions to create search queries and song titles and file names. create_file_name ( song , template , file_extension , short = False ) \u00a4 Create the file name for the song, by replacing template variables with the actual values. Arguments \u00a4 song: the song object template: the template string file_extension: the file extension to use short: whether to use the short version of the template Returns \u00a4 the formatted string as a Path object Source code in spotdl/utils/formatter.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def create_file_name ( song : Song , template : str , file_extension : str , short : bool = False , ) -> Path : \"\"\" Create the file name for the song, by replacing template variables with the actual values. ### Arguments - song: the song object - template: the template string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string as a Path object \"\"\" # If template does not contain any of the keys, # append {artists} - {title}.{output-ext} to it if not any ( key in template for key in VARS ): template += \"/ {artists} - {title} .{output-ext}\" # If template ends with a slash. Does not have a file name with extension # at the end of the template, append {artists} - {title}.{output-ext} to it if template . endswith ( \"/\" ) or template . endswith ( r \" \\\\ \" ) or template . endswith ( \" \\\\\\\\ \" ): template += \"/ {artists} - {title} .{output-ext}\" # If template does not end with {output-ext}, append it to the end of the template if not template . endswith ( \".{output-ext}\" ): template += \".{output-ext}\" formatted_string = format_query ( song = song , template = template , santitize = True , file_extension = file_extension , short = short , ) # Parse template as Path object file = Path ( formatted_string ) santitized_parts = [] for part in file . parts : match = re . search ( r \"[^\\.*](.*)[^\\.*$]\" , part ) if match and part != \".spotdl\" : santitized_parts . append ( match . group ( 0 )) else : santitized_parts . append ( part ) # Join the parts of the path file = Path ( * santitized_parts ) # Check if the file name length is greater than 255 if len ( file . name ) > 255 : # If the file name length is greater than 255, # and we are already using the short version of the template, # fallback to default template if short is True : warnings . warn ( f \" { song . display_name } : File name is too long. Using the default template.\" ) return create_file_name ( song = song , template = \"/ {artist} - {title} .{output-ext}\" , file_extension = file_extension , short = short , ) # This will probably never occur, but just in case if short is True and template == \"/ {artist} - {title} .{output-ext}\" : raise RecursionError ( f '\" { song . display_name } is too long to be shortened. File a bug report on GitHub' ) return create_file_name ( song , template , file_extension , short = True , ) return file create_search_query ( song , template , santitize , file_extension = None , short = False ) \u00a4 Create the search query for the song. Arguments \u00a4 song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template Returns \u00a4 the formatted string Source code in spotdl/utils/formatter.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def create_search_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Create the search query for the song. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" # If template does not contain any of the keys, # append {artist} - {title} at the beggining of the template if not any ( key in template for key in VARS ): template = \" {artist} - {title} \" + template return format_query ( song , template , santitize , file_extension , short = short ) create_song_title ( song_name , song_artists ) \u00a4 Create the song title. Arguments \u00a4 song_name: the name of the song song_artists: the list of artists of the song Returns \u00a4 the song title Notes \u00a4 Example: \"Artist1, Artist2 - Song Name\" Source code in spotdl/utils/formatter.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def create_song_title ( song_name : str , song_artists : List [ str ]) -> str : \"\"\" Create the song title. ### Arguments - song_name: the name of the song - song_artists: the list of artists of the song ### Returns - the song title ### Notes - Example: \"Artist1, Artist2 - Song Name\" \"\"\" joined_artists = \", \" . join ( song_artists ) if len ( song_artists ) >= 1 : return f \" { joined_artists } - { song_name } \" return song_name format_query ( song , template , santitize , file_extension = None , short = False ) \u00a4 Replace template variables with the actual values. Arguments \u00a4 song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template Returns \u00a4 the formatted string Source code in spotdl/utils/formatter.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def format_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Replace template variables with the actual values. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" if \"{output-ext}\" in template and file_extension is None : raise ValueError ( \"file_extension is None, but template contains {output-ext}\" ) if ( any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]) and song . song_list is None ): # If the template contains {list-length} or {list-position} or {list-name}, # but the song_list is None, replace them with empty strings for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]: template = template . replace ( k , \"\" ) template = template . replace ( r \"//\" , r \"/\" ) # If template has only {output-ext}, fix it # This can happen if the template consits of only list values # and song.song_list is None if template in [ \"/.{output-ext}\" , \".{output-ext}\" ]: template = \" {artists} - {title} .{output-ext}\" # Remove artists from the list that are already in the title artists = [ artist for artist in song . artists if slugify ( artist ) not in slugify ( song . name ) ] # Add the main artist again to the list if len ( artists ) == 0 or artists [ 0 ] != song . artists [ 0 ]: artists . insert ( 0 , song . artists [ 0 ]) artists_str = \", \" . join ( artists ) # the code below is valid, song_list is actually checked for None formats = { \" {title} \" : song . name , \" {artists} \" : song . artists [ 0 ] if short is True else artists_str , \" {artist} \" : song . artists [ 0 ], \" {album} \" : song . album_name , \"{album-artist}\" : song . album_artist , \" {genre} \" : song . genres [ 0 ] if len ( song . genres ) > 0 else \"\" , \"{disc-number}\" : song . disc_number , \"{disc-count}\" : song . disc_count , \" {duration} \" : song . duration , \" {year} \" : song . year , \"{original-date}\" : song . date , \"{track-number}\" : song . track_number , \"{tracks-count}\" : song . tracks_count , \" {isrc} \" : song . isrc , \"{track-id}\" : song . song_id , \" {publisher} \" : song . publisher , \"{output-ext}\" : file_extension , } if song . song_list and any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ] ): try : index = song . song_list . songs . index ( song ) except ValueError : index = song . song_list . urls . index ( song . url ) formats . update ( { \"{list-name}\" : song . song_list . name , # type: ignore \"{list-position}\" : str ( index + 1 ) . zfill ( len ( str ( song . song_list . length )) ), \"{list-length}\" : song . song_list . length , } ) if santitize : # sanitize the values in formats dict for key , value in formats . items (): if value is None : continue formats [ key ] = sanitize_string ( str ( value )) # Replace all the keys with the values for key , value in formats . items (): template = template . replace ( key , str ( value )) return template parse_duration ( duration ) \u00a4 Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0) Arguments \u00a4 duration: the string value of time Returns \u00a4 the float value of seconds Source code in spotdl/utils/formatter.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def parse_duration ( duration : Optional [ str ]) -> float : \"\"\" Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0) ### Arguments - duration: the string value of time ### Returns - the float value of seconds \"\"\" if duration is None : return 0.0 try : # {(1, \"s\"), (60, \"m\"), (3600, \"h\")} mapped_increments = zip ([ 1 , 60 , 3600 ], reversed ( duration . split ( \":\" ))) seconds = sum ( multiplier * int ( time ) for multiplier , time in mapped_increments ) return float ( seconds ) # This usually occurs when the wrong string is mistaken for the duration except ( ValueError , TypeError , AttributeError ): return 0.0 restrict_filename ( pathobj ) \u00a4 Sanitizes the filename part of a Path object. Returns modified object. Arguments \u00a4 pathobj: the Path object to sanitize Returns \u00a4 the modified Path object Notes \u00a4 Based on the sanitize_filename function from yt-dlp Source code in spotdl/utils/formatter.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def restrict_filename ( pathobj : Path ) -> Path : \"\"\" Sanitizes the filename part of a Path object. Returns modified object. ### Arguments - pathobj: the Path object to sanitize ### Returns - the modified Path object ### Notes - Based on the `sanitize_filename` function from yt-dlp \"\"\" result = sanitize_filename ( pathobj . name , True , False ) result = result . replace ( \"_-_\" , \"-\" ) if not result : result = \"_\" return pathobj . with_name ( result ) sanitize_string ( string ) \u00a4 Sanitize the filename to be used in the file system. Arguments \u00a4 string: the string to sanitize Returns \u00a4 the sanitized string Source code in spotdl/utils/formatter.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def sanitize_string ( string : str ) -> str : \"\"\" Sanitize the filename to be used in the file system. ### Arguments - string: the string to sanitize ### Returns - the sanitized string \"\"\" output = string # this is windows specific (disallowed chars) output = \"\" . join ( char for char in output if char not in \"/? \\\\ *|<>\" ) # double quotes (\") and semi-colons (:) are also disallowed characters but we would # like to retain their equivalents, so they aren't removed in the prior loop output = output . replace ( '\"' , \"'\" ) . replace ( \":\" , \"-\" ) return output to_ms ( string = None , precision = None , ** kwargs ) \u00a4 Convert a string to milliseconds. Arguments \u00a4 string: the string to convert precision: the number of decimals to round to kwargs: the keyword args to convert Returns \u00a4 the milliseconds Notes \u00a4 You can either pass a string, or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. If \"precision\" is set, the result is rounded to the number of decimals given. From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 Source code in spotdl/utils/formatter.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float : \"\"\" Convert a string to milliseconds. ### Arguments - string: the string to convert - precision: the number of decimals to round to - kwargs: the keyword args to convert ### Returns - the milliseconds ### Notes - You can either pass a string, - or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. - If \"precision\" is set, the result is rounded to the number of decimals given. - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 \"\"\" if string : hour = int ( string [ 0 : 2 ]) minute = int ( string [ 3 : 5 ]) sec = int ( string [ 6 : 8 ]) milliseconds = int ( string [ 10 : 11 ]) else : hour = int ( kwargs . get ( \"hour\" , 0 )) minute = int ( kwargs . get ( \"min\" , 0 )) sec = int ( kwargs . get ( \"sec\" , 0 )) milliseconds = int ( kwargs . get ( \"ms\" , 0 )) result = ( ( hour * 60 * 60 * 1000 ) + ( minute * 60 * 1000 ) + ( sec * 1000 ) + milliseconds ) if precision and isinstance ( precision , int ): return round ( result , precision ) return result","title":"formatter"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name","text":"Create the file name for the song, by replacing template variables with the actual values.","title":"create_file_name()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name--arguments","text":"song: the song object template: the template string file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name--returns","text":"the formatted string as a Path object Source code in spotdl/utils/formatter.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def create_file_name ( song : Song , template : str , file_extension : str , short : bool = False , ) -> Path : \"\"\" Create the file name for the song, by replacing template variables with the actual values. ### Arguments - song: the song object - template: the template string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string as a Path object \"\"\" # If template does not contain any of the keys, # append {artists} - {title}.{output-ext} to it if not any ( key in template for key in VARS ): template += \"/ {artists} - {title} .{output-ext}\" # If template ends with a slash. Does not have a file name with extension # at the end of the template, append {artists} - {title}.{output-ext} to it if template . endswith ( \"/\" ) or template . endswith ( r \" \\\\ \" ) or template . endswith ( \" \\\\\\\\ \" ): template += \"/ {artists} - {title} .{output-ext}\" # If template does not end with {output-ext}, append it to the end of the template if not template . endswith ( \".{output-ext}\" ): template += \".{output-ext}\" formatted_string = format_query ( song = song , template = template , santitize = True , file_extension = file_extension , short = short , ) # Parse template as Path object file = Path ( formatted_string ) santitized_parts = [] for part in file . parts : match = re . search ( r \"[^\\.*](.*)[^\\.*$]\" , part ) if match and part != \".spotdl\" : santitized_parts . append ( match . group ( 0 )) else : santitized_parts . append ( part ) # Join the parts of the path file = Path ( * santitized_parts ) # Check if the file name length is greater than 255 if len ( file . name ) > 255 : # If the file name length is greater than 255, # and we are already using the short version of the template, # fallback to default template if short is True : warnings . warn ( f \" { song . display_name } : File name is too long. Using the default template.\" ) return create_file_name ( song = song , template = \"/ {artist} - {title} .{output-ext}\" , file_extension = file_extension , short = short , ) # This will probably never occur, but just in case if short is True and template == \"/ {artist} - {title} .{output-ext}\" : raise RecursionError ( f '\" { song . display_name } is too long to be shortened. File a bug report on GitHub' ) return create_file_name ( song , template , file_extension , short = True , ) return file","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query","text":"Create the search query for the song.","title":"create_search_query()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query--arguments","text":"song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query--returns","text":"the formatted string Source code in spotdl/utils/formatter.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def create_search_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Create the search query for the song. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" # If template does not contain any of the keys, # append {artist} - {title} at the beggining of the template if not any ( key in template for key in VARS ): template = \" {artist} - {title} \" + template return format_query ( song , template , santitize , file_extension , short = short )","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title","text":"Create the song title.","title":"create_song_title()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--arguments","text":"song_name: the name of the song song_artists: the list of artists of the song","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--returns","text":"the song title","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--notes","text":"Example: \"Artist1, Artist2 - Song Name\" Source code in spotdl/utils/formatter.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def create_song_title ( song_name : str , song_artists : List [ str ]) -> str : \"\"\" Create the song title. ### Arguments - song_name: the name of the song - song_artists: the list of artists of the song ### Returns - the song title ### Notes - Example: \"Artist1, Artist2 - Song Name\" \"\"\" joined_artists = \", \" . join ( song_artists ) if len ( song_artists ) >= 1 : return f \" { joined_artists } - { song_name } \" return song_name","title":"Notes"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query","text":"Replace template variables with the actual values.","title":"format_query()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query--arguments","text":"song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query--returns","text":"the formatted string Source code in spotdl/utils/formatter.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def format_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Replace template variables with the actual values. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" if \"{output-ext}\" in template and file_extension is None : raise ValueError ( \"file_extension is None, but template contains {output-ext}\" ) if ( any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]) and song . song_list is None ): # If the template contains {list-length} or {list-position} or {list-name}, # but the song_list is None, replace them with empty strings for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]: template = template . replace ( k , \"\" ) template = template . replace ( r \"//\" , r \"/\" ) # If template has only {output-ext}, fix it # This can happen if the template consits of only list values # and song.song_list is None if template in [ \"/.{output-ext}\" , \".{output-ext}\" ]: template = \" {artists} - {title} .{output-ext}\" # Remove artists from the list that are already in the title artists = [ artist for artist in song . artists if slugify ( artist ) not in slugify ( song . name ) ] # Add the main artist again to the list if len ( artists ) == 0 or artists [ 0 ] != song . artists [ 0 ]: artists . insert ( 0 , song . artists [ 0 ]) artists_str = \", \" . join ( artists ) # the code below is valid, song_list is actually checked for None formats = { \" {title} \" : song . name , \" {artists} \" : song . artists [ 0 ] if short is True else artists_str , \" {artist} \" : song . artists [ 0 ], \" {album} \" : song . album_name , \"{album-artist}\" : song . album_artist , \" {genre} \" : song . genres [ 0 ] if len ( song . genres ) > 0 else \"\" , \"{disc-number}\" : song . disc_number , \"{disc-count}\" : song . disc_count , \" {duration} \" : song . duration , \" {year} \" : song . year , \"{original-date}\" : song . date , \"{track-number}\" : song . track_number , \"{tracks-count}\" : song . tracks_count , \" {isrc} \" : song . isrc , \"{track-id}\" : song . song_id , \" {publisher} \" : song . publisher , \"{output-ext}\" : file_extension , } if song . song_list and any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ] ): try : index = song . song_list . songs . index ( song ) except ValueError : index = song . song_list . urls . index ( song . url ) formats . update ( { \"{list-name}\" : song . song_list . name , # type: ignore \"{list-position}\" : str ( index + 1 ) . zfill ( len ( str ( song . song_list . length )) ), \"{list-length}\" : song . song_list . length , } ) if santitize : # sanitize the values in formats dict for key , value in formats . items (): if value is None : continue formats [ key ] = sanitize_string ( str ( value )) # Replace all the keys with the values for key , value in formats . items (): template = template . replace ( key , str ( value )) return template","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration","text":"Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0)","title":"parse_duration()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration--arguments","text":"duration: the string value of time","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration--returns","text":"the float value of seconds Source code in spotdl/utils/formatter.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def parse_duration ( duration : Optional [ str ]) -> float : \"\"\" Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0) ### Arguments - duration: the string value of time ### Returns - the float value of seconds \"\"\" if duration is None : return 0.0 try : # {(1, \"s\"), (60, \"m\"), (3600, \"h\")} mapped_increments = zip ([ 1 , 60 , 3600 ], reversed ( duration . split ( \":\" ))) seconds = sum ( multiplier * int ( time ) for multiplier , time in mapped_increments ) return float ( seconds ) # This usually occurs when the wrong string is mistaken for the duration except ( ValueError , TypeError , AttributeError ): return 0.0","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename","text":"Sanitizes the filename part of a Path object. Returns modified object.","title":"restrict_filename()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--arguments","text":"pathobj: the Path object to sanitize","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--returns","text":"the modified Path object","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--notes","text":"Based on the sanitize_filename function from yt-dlp Source code in spotdl/utils/formatter.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def restrict_filename ( pathobj : Path ) -> Path : \"\"\" Sanitizes the filename part of a Path object. Returns modified object. ### Arguments - pathobj: the Path object to sanitize ### Returns - the modified Path object ### Notes - Based on the `sanitize_filename` function from yt-dlp \"\"\" result = sanitize_filename ( pathobj . name , True , False ) result = result . replace ( \"_-_\" , \"-\" ) if not result : result = \"_\" return pathobj . with_name ( result )","title":"Notes"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string","text":"Sanitize the filename to be used in the file system.","title":"sanitize_string()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string--arguments","text":"string: the string to sanitize","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string--returns","text":"the sanitized string Source code in spotdl/utils/formatter.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def sanitize_string ( string : str ) -> str : \"\"\" Sanitize the filename to be used in the file system. ### Arguments - string: the string to sanitize ### Returns - the sanitized string \"\"\" output = string # this is windows specific (disallowed chars) output = \"\" . join ( char for char in output if char not in \"/? \\\\ *|<>\" ) # double quotes (\") and semi-colons (:) are also disallowed characters but we would # like to retain their equivalents, so they aren't removed in the prior loop output = output . replace ( '\"' , \"'\" ) . replace ( \":\" , \"-\" ) return output","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms","text":"Convert a string to milliseconds.","title":"to_ms()"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--arguments","text":"string: the string to convert precision: the number of decimals to round to kwargs: the keyword args to convert","title":"Arguments"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--returns","text":"the milliseconds","title":"Returns"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--notes","text":"You can either pass a string, or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. If \"precision\" is set, the result is rounded to the number of decimals given. From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 Source code in spotdl/utils/formatter.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float : \"\"\" Convert a string to milliseconds. ### Arguments - string: the string to convert - precision: the number of decimals to round to - kwargs: the keyword args to convert ### Returns - the milliseconds ### Notes - You can either pass a string, - or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. - If \"precision\" is set, the result is rounded to the number of decimals given. - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 \"\"\" if string : hour = int ( string [ 0 : 2 ]) minute = int ( string [ 3 : 5 ]) sec = int ( string [ 6 : 8 ]) milliseconds = int ( string [ 10 : 11 ]) else : hour = int ( kwargs . get ( \"hour\" , 0 )) minute = int ( kwargs . get ( \"min\" , 0 )) sec = int ( kwargs . get ( \"sec\" , 0 )) milliseconds = int ( kwargs . get ( \"ms\" , 0 )) result = ( ( hour * 60 * 60 * 1000 ) + ( minute * 60 * 1000 ) + ( sec * 1000 ) + milliseconds ) if precision and isinstance ( precision , int ): return round ( result , precision ) return result","title":"Notes"},{"location":"reference/utils/github/","text":"Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates. check_for_updates ( repo = REPO ) \u00a4 Check for updates to the current version. Arguments \u00a4 repo: the repo to check (defaults to spotdl/spotify-downloader) Returns \u00a4 the latest version Source code in spotdl/utils/github.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def check_for_updates ( repo : str = REPO ) -> str : \"\"\" Check for updates to the current version. ### Arguments - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - the latest version \"\"\" message = \"\" url = f \"https://api.github.com/repos/ { repo } /releases/latest\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () latest_version = data [ \"name\" ] # returns \"vx.x.x\" current_version = f \"v { _version . __version__ } \" # returns \"vx.x.x\" if latest_version != current_version : message = f \"New version available: { latest_version } . \\n\\n \" else : message = \"No updates available. \\n\\n \" master = get_status ( current_version , \"master\" ) dev = get_status ( current_version , \"dev\" ) for branch in [ \"master\" , \"dev\" ]: name = branch . capitalize () if branch == \"master\" : status , ahead_by , behind_by = master else : status , ahead_by , behind_by = dev if status == \"behind\" : message += f \" { name } is { status } by { behind_by } commits. \\n \" elif status == \"ahead\" : message += f \" { name } is { status } by { ahead_by } commits. \\n \" else : message += f \" { name } is up to date. \\n \" return message create_github_url ( url = WEB_APP_URL ) \u00a4 From the given url, produce a URL that is compatible with Github's REST API. Arguments \u00a4 url: the url to convert Notes \u00a4 Can handle blob or tree paths. Source code in spotdl/utils/github.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def create_github_url ( url : str = WEB_APP_URL ): \"\"\" From the given url, produce a URL that is compatible with Github's REST API. ### Arguments - url: the url to convert ### Notes - Can handle blob or tree paths. \"\"\" repo_only_url = re . compile ( r \"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\" ) re_branch = re . compile ( \"/(tree|blob)/(.+?)/\" ) # Check if the given url is a url to a GitHub repo. If it is, tell the # user to use 'git clone' to download it if re . match ( repo_only_url , url ): raise ValueError ( \"The given URL is a GitHub repo. Please use 'git clone' to download it.\" ) # extract the branch name from the given url (e.g master) branch = re_branch . search ( url ) if branch : download_dirs = url [ branch . end () :] api_url = ( url [: branch . start ()] . replace ( \"github.com\" , \"api.github.com/repos\" , 1 ) + \"/contents/\" + download_dirs + \"?ref=\" + branch . group ( 2 ) ) return api_url raise ValueError ( \"The given url is not a valid GitHub url\" ) download_github_dir ( repo_url = WEB_APP_URL , flatten = False , output_dir = './' ) \u00a4 Downloads the files and directories in repo_url. Arguments \u00a4 repo_url: the url to the repo to download flatten: whether to flatten the directory structure output_dir: the directory to download the files to Notes \u00a4 Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py Source code in spotdl/utils/github.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def download_github_dir ( repo_url : str = WEB_APP_URL , flatten : bool = False , output_dir : str = \"./\" ): \"\"\" Downloads the files and directories in repo_url. ### Arguments - repo_url: the url to the repo to download - flatten: whether to flatten the directory structure - output_dir: the directory to download the files to ### Notes - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py \"\"\" # generate the url which returns the JSON data api_url = create_github_url ( repo_url ) dir_out = output_dir response = requests . get ( api_url ) . json () if ( type ( response ) is dict and \"message\" in response . keys () and \"rate limit\" in response [ \"message\" ] ): logging . error ( \"\"\"You have been rate limited by Github API attempting to update web client. Proceeding with cached web client. Please try again later. See https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting\"\"\" ) return if not flatten : # make a directory with the name which is taken from # the actual repo os . makedirs ( dir_out , exist_ok = True ) if isinstance ( response , dict ) and response [ \"type\" ] == \"file\" : response = [ response ] for file in response : file_url = file [ \"download_url\" ] if flatten : path = os . path . join ( dir_out , os . path . basename ( file [ \"path\" ])) else : path = os . path . join ( dir_out , file [ \"path\" ]) dirname = os . path . dirname ( path ) if dirname != \"\" : os . makedirs ( dirname , exist_ok = True ) if file_url is not None : with open ( path , \"wb\" ) as new_file : new_file . write ( requests . get ( file_url ) . content ) else : download_github_dir ( file [ \"html_url\" ], flatten , output_dir ) get_status ( start , end , repo = REPO ) \u00a4 Get the status of a commit range. Arguments \u00a4 start: the starting commit/branch/tag end: the ending commit/branch/tag repo: the repo to check (defaults to spotdl/spotify-downloader) Returns \u00a4 tuple of (status, ahead_by, behind_by) Source code in spotdl/utils/github.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_status ( start : str , end : str , repo : str = REPO ) -> Tuple [ str , int , int ]: \"\"\" Get the status of a commit range. ### Arguments - start: the starting commit/branch/tag - end: the ending commit/branch/tag - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - tuple of (status, ahead_by, behind_by) \"\"\" url = f \"https://api.github.com/repos/ { repo } /compare/ { start } ... { end } \" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () return ( data [ \"status\" ], data [ \"ahead_by\" ], data [ \"behind_by\" ], )","title":"github"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates","text":"Check for updates to the current version.","title":"check_for_updates()"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates--arguments","text":"repo: the repo to check (defaults to spotdl/spotify-downloader)","title":"Arguments"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates--returns","text":"the latest version Source code in spotdl/utils/github.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def check_for_updates ( repo : str = REPO ) -> str : \"\"\" Check for updates to the current version. ### Arguments - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - the latest version \"\"\" message = \"\" url = f \"https://api.github.com/repos/ { repo } /releases/latest\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () latest_version = data [ \"name\" ] # returns \"vx.x.x\" current_version = f \"v { _version . __version__ } \" # returns \"vx.x.x\" if latest_version != current_version : message = f \"New version available: { latest_version } . \\n\\n \" else : message = \"No updates available. \\n\\n \" master = get_status ( current_version , \"master\" ) dev = get_status ( current_version , \"dev\" ) for branch in [ \"master\" , \"dev\" ]: name = branch . capitalize () if branch == \"master\" : status , ahead_by , behind_by = master else : status , ahead_by , behind_by = dev if status == \"behind\" : message += f \" { name } is { status } by { behind_by } commits. \\n \" elif status == \"ahead\" : message += f \" { name } is { status } by { ahead_by } commits. \\n \" else : message += f \" { name } is up to date. \\n \" return message","title":"Returns"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url","text":"From the given url, produce a URL that is compatible with Github's REST API.","title":"create_github_url()"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url--arguments","text":"url: the url to convert","title":"Arguments"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url--notes","text":"Can handle blob or tree paths. Source code in spotdl/utils/github.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def create_github_url ( url : str = WEB_APP_URL ): \"\"\" From the given url, produce a URL that is compatible with Github's REST API. ### Arguments - url: the url to convert ### Notes - Can handle blob or tree paths. \"\"\" repo_only_url = re . compile ( r \"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\" ) re_branch = re . compile ( \"/(tree|blob)/(.+?)/\" ) # Check if the given url is a url to a GitHub repo. If it is, tell the # user to use 'git clone' to download it if re . match ( repo_only_url , url ): raise ValueError ( \"The given URL is a GitHub repo. Please use 'git clone' to download it.\" ) # extract the branch name from the given url (e.g master) branch = re_branch . search ( url ) if branch : download_dirs = url [ branch . end () :] api_url = ( url [: branch . start ()] . replace ( \"github.com\" , \"api.github.com/repos\" , 1 ) + \"/contents/\" + download_dirs + \"?ref=\" + branch . group ( 2 ) ) return api_url raise ValueError ( \"The given url is not a valid GitHub url\" )","title":"Notes"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir","text":"Downloads the files and directories in repo_url.","title":"download_github_dir()"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir--arguments","text":"repo_url: the url to the repo to download flatten: whether to flatten the directory structure output_dir: the directory to download the files to","title":"Arguments"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir--notes","text":"Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py Source code in spotdl/utils/github.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def download_github_dir ( repo_url : str = WEB_APP_URL , flatten : bool = False , output_dir : str = \"./\" ): \"\"\" Downloads the files and directories in repo_url. ### Arguments - repo_url: the url to the repo to download - flatten: whether to flatten the directory structure - output_dir: the directory to download the files to ### Notes - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py \"\"\" # generate the url which returns the JSON data api_url = create_github_url ( repo_url ) dir_out = output_dir response = requests . get ( api_url ) . json () if ( type ( response ) is dict and \"message\" in response . keys () and \"rate limit\" in response [ \"message\" ] ): logging . error ( \"\"\"You have been rate limited by Github API attempting to update web client. Proceeding with cached web client. Please try again later. See https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting\"\"\" ) return if not flatten : # make a directory with the name which is taken from # the actual repo os . makedirs ( dir_out , exist_ok = True ) if isinstance ( response , dict ) and response [ \"type\" ] == \"file\" : response = [ response ] for file in response : file_url = file [ \"download_url\" ] if flatten : path = os . path . join ( dir_out , os . path . basename ( file [ \"path\" ])) else : path = os . path . join ( dir_out , file [ \"path\" ]) dirname = os . path . dirname ( path ) if dirname != \"\" : os . makedirs ( dirname , exist_ok = True ) if file_url is not None : with open ( path , \"wb\" ) as new_file : new_file . write ( requests . get ( file_url ) . content ) else : download_github_dir ( file [ \"html_url\" ], flatten , output_dir )","title":"Notes"},{"location":"reference/utils/github/#spotdl.utils.github.get_status","text":"Get the status of a commit range.","title":"get_status()"},{"location":"reference/utils/github/#spotdl.utils.github.get_status--arguments","text":"start: the starting commit/branch/tag end: the ending commit/branch/tag repo: the repo to check (defaults to spotdl/spotify-downloader)","title":"Arguments"},{"location":"reference/utils/github/#spotdl.utils.github.get_status--returns","text":"tuple of (status, ahead_by, behind_by) Source code in spotdl/utils/github.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_status ( start : str , end : str , repo : str = REPO ) -> Tuple [ str , int , int ]: \"\"\" Get the status of a commit range. ### Arguments - start: the starting commit/branch/tag - end: the ending commit/branch/tag - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - tuple of (status, ahead_by, behind_by) \"\"\" url = f \"https://api.github.com/repos/ { repo } /compare/ { start } ... { end } \" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () return ( data [ \"status\" ], data [ \"ahead_by\" ], data [ \"behind_by\" ], )","title":"Returns"},{"location":"reference/utils/m3u/","text":"Module for creating m3u content and writing it to a file. create_m3u_content ( song_list , template , file_extension , short = False ) \u00a4 Create m3u content and return it as a string. Arguments \u00a4 song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template Returns \u00a4 the m3u content as a string Source code in spotdl/utils/m3u.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def create_m3u_content ( song_list : List [ Song ], template : str , file_extension : str , short : bool = False ) -> str : \"\"\" Create m3u content and return it as a string. ### Arguments - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" text = \"\" for song in song_list : text += str ( create_file_name ( song , template , file_extension , short )) + \" \\n \" return text create_m3u_file ( file_name , song_list , template , file_extension , short = False ) \u00a4 Create the m3u file. Arguments \u00a4 file_name: the file name to use song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template Returns \u00a4 the m3u content as a string Source code in spotdl/utils/m3u.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def create_m3u_file ( file_name : str , song_list : List [ Song ], template : str , file_extension : str , short : bool = False , ) -> str : \"\"\" Create the m3u file. ### Arguments - file_name: the file name to use - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" m3u_content = create_m3u_content ( song_list , template , file_extension , short ) with open ( file_name , \"w\" , encoding = \"utf-8\" ) as m3u_file : m3u_file . write ( m3u_content ) return m3u_content","title":"m3u"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content","text":"Create m3u content and return it as a string.","title":"create_m3u_content()"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content--arguments","text":"song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content--returns","text":"the m3u content as a string Source code in spotdl/utils/m3u.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def create_m3u_content ( song_list : List [ Song ], template : str , file_extension : str , short : bool = False ) -> str : \"\"\" Create m3u content and return it as a string. ### Arguments - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" text = \"\" for song in song_list : text += str ( create_file_name ( song , template , file_extension , short )) + \" \\n \" return text","title":"Returns"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file","text":"Create the m3u file.","title":"create_m3u_file()"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file--arguments","text":"file_name: the file name to use song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file--returns","text":"the m3u content as a string Source code in spotdl/utils/m3u.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def create_m3u_file ( file_name : str , song_list : List [ Song ], template : str , file_extension : str , short : bool = False , ) -> str : \"\"\" Create the m3u file. ### Arguments - file_name: the file name to use - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" m3u_content = create_m3u_content ( song_list , template , file_extension , short ) with open ( file_name , \"w\" , encoding = \"utf-8\" ) as m3u_file : m3u_file . write ( m3u_content ) return m3u_content","title":"Returns"},{"location":"reference/utils/metadata/","text":"Module for embedding metadata into audio files using Mutagen. embed_metadata ( output_file = Path ( \"test.mp3\" ), song = song_object , file_format = \"mp3\" , ) MetadataError \u00a4 Bases: Exception Base class for all exceptions related to metadata and id3 embedding. embed_metadata ( output_file , song , file_format ) \u00a4 Embeds metadata into the output file. Arguments \u00a4 output_file: Path to the output file. song: Song object. file_format: File format of the output file. Source code in spotdl/utils/metadata.py 321 322 323 324 325 326 327 328 329 330 331 332 333 def embed_metadata ( output_file : Path , song : Song , file_format : str ) -> None : \"\"\" Embeds metadata into the output file. ### Arguments - output_file: Path to the output file. - song: Song object. - file_format: File format of the output file. \"\"\" function = AVAILABLE_FORMATS . get ( file_format ) if function : function ( output_file , song ) set_id3_flac ( output_file , song ) \u00a4 Set ID3 tags for FLAC files. Arguments \u00a4 output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def set_id3_flac ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for FLAC files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = FLAC ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"flac\" ) audio_file = _embed_ogg_metadata ( audio_file , song ) audio_file = _embed_cover ( audio_file , song , \"flac\" ) audio_file . save () set_id3_m4a ( output_file , song ) \u00a4 Set ID3 tags for M4A files. Arguments \u00a4 output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def set_id3_m4a ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for M4A files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = MP4 ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"m4a\" , M4A_TAG_PRESET ) audio_file [ M4A_TAG_PRESET [ \"year\" ]] = str ( song . year ) audio_file [ M4A_TAG_PRESET [ \"explicit\" ]] = ( 4 if song . explicit is True else 2 ,) if song . lyrics : audio_file [ M4A_TAG_PRESET [ \"lyrics\" ]] = song . lyrics if song . cover_url : try : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ M4A_TAG_PRESET [ \"albumart\" ]] = [ MP4Cover ( raw_album_art . read (), imageformat = MP4Cover . FORMAT_JPEG , ) ] except IndexError : pass if song . download_url : audio_file [ M4A_TAG_PRESET [ \"comment\" ]] = song . download_url audio_file . save () set_id3_mp3 ( output_file , song ) \u00a4 Set ID3 tags for MP3 files. Arguments \u00a4 output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def set_id3_mp3 ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for MP3 files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = EasyID3 ( str ( output_file . resolve ())) audio_file . delete () audio_file [ \"title\" ] = song . name audio_file [ \"titlesort\" ] = song . name audio_file [ \"tracknumber\" ] = [ song . track_number , song . tracks_count ] audio_file [ \"discnumber\" ] = [ song . disc_number , song . disc_count ] audio_file [ \"artist\" ] = song . artists audio_file [ \"album\" ] = song . album_name audio_file [ \"albumartist\" ] = song . album_artist audio_file [ \"date\" ] = song . date audio_file [ \"originaldate\" ] = song . date audio_file [ \"encodedby\" ] = song . publisher if song . copyright_text : audio_file [ \"copyright\" ] = song . copyright_text genres = song . genres if len ( genres ) > 0 : audio_file [ \"genre\" ] = genres [ 0 ] audio_file . save ( v2_version = 3 ) audio_file = ID3 ( str ( output_file . resolve ())) if song . cover_url : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ \"APIC\" ] = AlbumCover ( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = raw_album_art . read (), ) if song . lyrics : audio_file [ \"USLT::'eng'\" ] = USLT ( encoding = 3 , lang = \"eng\" , desc = \"desc\" , text = song . lyrics ) if song . download_url : audio_file . add ( Comment ( encoding = 3 , text = song . download_url )) audio_file . save ( v2_version = 3 ) set_id3_ogg ( output_file , song ) \u00a4 Set ID3 tags for OGG files. Arguments \u00a4 output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def set_id3_ogg ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for OGG files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = OggVorbis ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"ogg\" ) audio_file = _embed_ogg_metadata ( audio_file , song ) audio_file = _embed_cover ( audio_file , song , \"ogg\" ) audio_file . save () set_id3_opus ( output_file , song ) \u00a4 Set ID3 tags for Opus files. Arguments \u00a4 output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_id3_opus ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for Opus files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = OggOpus ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"opus\" ) audio_file = _embed_ogg_metadata ( audio_file , song ) audio_file = _embed_cover ( audio_file , song , \"opus\" ) audio_file . save ()","title":"metadata"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.MetadataError","text":"Bases: Exception Base class for all exceptions related to metadata and id3 embedding.","title":"MetadataError"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_metadata","text":"Embeds metadata into the output file.","title":"embed_metadata()"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_metadata--arguments","text":"output_file: Path to the output file. song: Song object. file_format: File format of the output file. Source code in spotdl/utils/metadata.py 321 322 323 324 325 326 327 328 329 330 331 332 333 def embed_metadata ( output_file : Path , song : Song , file_format : str ) -> None : \"\"\" Embeds metadata into the output file. ### Arguments - output_file: Path to the output file. - song: Song object. - file_format: File format of the output file. \"\"\" function = AVAILABLE_FORMATS . get ( file_format ) if function : function ( output_file , song )","title":"Arguments"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_flac","text":"Set ID3 tags for FLAC files.","title":"set_id3_flac()"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_flac--arguments","text":"output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def set_id3_flac ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for FLAC files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = FLAC ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"flac\" ) audio_file = _embed_ogg_metadata ( audio_file , song ) audio_file = _embed_cover ( audio_file , song , \"flac\" ) audio_file . save ()","title":"Arguments"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_m4a","text":"Set ID3 tags for M4A files.","title":"set_id3_m4a()"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_m4a--arguments","text":"output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def set_id3_m4a ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for M4A files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = MP4 ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"m4a\" , M4A_TAG_PRESET ) audio_file [ M4A_TAG_PRESET [ \"year\" ]] = str ( song . year ) audio_file [ M4A_TAG_PRESET [ \"explicit\" ]] = ( 4 if song . explicit is True else 2 ,) if song . lyrics : audio_file [ M4A_TAG_PRESET [ \"lyrics\" ]] = song . lyrics if song . cover_url : try : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ M4A_TAG_PRESET [ \"albumart\" ]] = [ MP4Cover ( raw_album_art . read (), imageformat = MP4Cover . FORMAT_JPEG , ) ] except IndexError : pass if song . download_url : audio_file [ M4A_TAG_PRESET [ \"comment\" ]] = song . download_url audio_file . save ()","title":"Arguments"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_mp3","text":"Set ID3 tags for MP3 files.","title":"set_id3_mp3()"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_mp3--arguments","text":"output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def set_id3_mp3 ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for MP3 files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = EasyID3 ( str ( output_file . resolve ())) audio_file . delete () audio_file [ \"title\" ] = song . name audio_file [ \"titlesort\" ] = song . name audio_file [ \"tracknumber\" ] = [ song . track_number , song . tracks_count ] audio_file [ \"discnumber\" ] = [ song . disc_number , song . disc_count ] audio_file [ \"artist\" ] = song . artists audio_file [ \"album\" ] = song . album_name audio_file [ \"albumartist\" ] = song . album_artist audio_file [ \"date\" ] = song . date audio_file [ \"originaldate\" ] = song . date audio_file [ \"encodedby\" ] = song . publisher if song . copyright_text : audio_file [ \"copyright\" ] = song . copyright_text genres = song . genres if len ( genres ) > 0 : audio_file [ \"genre\" ] = genres [ 0 ] audio_file . save ( v2_version = 3 ) audio_file = ID3 ( str ( output_file . resolve ())) if song . cover_url : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ \"APIC\" ] = AlbumCover ( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = raw_album_art . read (), ) if song . lyrics : audio_file [ \"USLT::'eng'\" ] = USLT ( encoding = 3 , lang = \"eng\" , desc = \"desc\" , text = song . lyrics ) if song . download_url : audio_file . add ( Comment ( encoding = 3 , text = song . download_url )) audio_file . save ( v2_version = 3 )","title":"Arguments"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_ogg","text":"Set ID3 tags for OGG files.","title":"set_id3_ogg()"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_ogg--arguments","text":"output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def set_id3_ogg ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for OGG files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = OggVorbis ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"ogg\" ) audio_file = _embed_ogg_metadata ( audio_file , song ) audio_file = _embed_cover ( audio_file , song , \"ogg\" ) audio_file . save ()","title":"Arguments"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_opus","text":"Set ID3 tags for Opus files.","title":"set_id3_opus()"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_opus--arguments","text":"output_file: Path to the output file. song: Song object. Source code in spotdl/utils/metadata.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_id3_opus ( output_file : Path , song : Song ): \"\"\" Set ID3 tags for Opus files. ### Arguments - output_file: Path to the output file. - song: Song object. \"\"\" audio_file = OggOpus ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"opus\" ) audio_file = _embed_ogg_metadata ( audio_file , song ) audio_file = _embed_cover ( audio_file , song , \"opus\" ) audio_file . save ()","title":"Arguments"},{"location":"reference/utils/search/","text":"Module for creating Song objects by interacting with Spotify API or by parsing a query. To use this module you must first initialize the SpotifyClient. QueryError \u00a4 Bases: Exception Base class for all exceptions related to query. create_empty_song ( name = None , artists = None , album_name = None , album_artist = None , genres = None , disc_number = None , disc_count = None , duration = None , year = None , date = None , track_number = None , tracks_count = None , isrc = None , song_id = None , cover_url = None , explicit = None , publisher = None , url = None , copyright_text = None , download_url = None , song_list = None ) \u00a4 Create an empty song. Arguments \u00a4 name: Name of the song artists: List of artists album_name: Name of the album album_artist: Name of the album artist genres: List of genres disc_number: Disc number disc_count: Disc count duration: Duration of the song in seconds year: Year of release date: Date of release track_number: Track number tracks_count: Number of tracks isrc: ISRC code song_id: Spotify song ID cover_url: URL of the cover art explicit: Explicit flag publisher: Publisher url: URL of the song copyright_text: Copyright text download_url: Download URL song_list: Song list Returns \u00a4 Song object Source code in spotdl/utils/search.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List [ str ]] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List [ str ]] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ \"SongList\" ] = None , ) -> Song : \"\"\" Create an empty song. ### Arguments - name: Name of the song - artists: List of artists - album_name: Name of the album - album_artist: Name of the album artist - genres: List of genres - disc_number: Disc number - disc_count: Disc count - duration: Duration of the song in seconds - year: Year of release - date: Date of release - track_number: Track number - tracks_count: Number of tracks - isrc: ISRC code - song_id: Spotify song ID - cover_url: URL of the cover art - explicit: Explicit flag - publisher: Publisher - url: URL of the song - copyright_text: Copyright text - download_url: Download URL - song_list: Song list ### Returns - Song object \"\"\" return Song ( name = name , # type: ignore artists = artists , # type: ignore artist = None if artists is None else artists [ 0 ], # type: ignore album_name = album_name , # type: ignore album_artist = album_artist , # type: ignore genres = genres , # type: ignore disc_number = disc_number , # type: ignore disc_count = disc_count , # type: ignore duration = duration , # type: ignore year = year , # type: ignore date = date , # type: ignore track_number = track_number , # type: ignore tracks_count = tracks_count , # type: ignore isrc = isrc , # type: ignore song_id = song_id , # type: ignore cover_url = cover_url , # type: ignore explicit = explicit , # type: ignore publisher = publisher , # type: ignore url = url , # type: ignore copyright_text = copyright_text , download_url = download_url , song_list = song_list , ) get_search_results ( search_term ) \u00a4 Creates a list of Song objects from a search term. Arguments \u00a4 search_term: the search term to use Returns \u00a4 a list of Song objects Source code in spotdl/utils/search.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def get_search_results ( search_term : str ) -> List [ Song ]: \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: the search term to use ### Returns - a list of Song objects \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) songs = [] for index , _ in enumerate ( raw_search_results [ \"tracks\" ][ \"items\" ]): songs . append ( Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ index ][ \"id\" ] ) ) return songs get_simple_songs ( query ) \u00a4 Parse query and return list containing simple song objects Arguments \u00a4 query: List of strings containing query Returns \u00a4 List of simple song objects Source code in spotdl/utils/search.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def get_simple_songs ( query : List [ str ], ) -> List [ Song ]: \"\"\" Parse query and return list containing simple song objects ### Arguments - query: List of strings containing query ### Returns - List of simple song objects \"\"\" songs : List [ Song ] = [] lists : List [ SongList ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( 'Incorrect format used, please use \"YouTubeURL|SpotifyURL\"' ) songs . append ( create_empty_song ( url = split_urls [ 1 ], download_url = split_urls [ 0 ]) ) elif \"open.spotify.com\" in request and \"track\" in request : songs . append ( create_empty_song ( url = request )) # type: ignore elif \"open.spotify.com\" in request and \"playlist\" in request : lists . append ( Playlist . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"album\" in request : lists . append ( Album . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : lists . append ( Artist . create_basic_list ( request )) elif request == \"saved\" : lists . append ( Saved . create_basic_list ()) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as save_file : for track in json . load ( save_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) for song_list in lists : songs . extend ( [ create_empty_song ( url = url , song_list = song_list ) for url in song_list . urls ] ) # type: ignore return songs parse_query ( query , threads = 1 ) \u00a4 Parse query and return list containing song object Arguments \u00a4 query: List of strings containing query threads: Number of threads to use Returns \u00a4 List of song objects Source code in spotdl/utils/search.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def parse_query ( query : List [ str ], threads : int = 1 , ) -> List [ Song ]: \"\"\" Parse query and return list containing song object ### Arguments - query: List of strings containing query - threads: Number of threads to use ### Returns - List of song objects \"\"\" urls : List [ str ] = [] songs : List [ Song ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( Song . from_dict ( { ** Song . from_url ( split_urls [ 1 ]) . json , \"download_url\" : split_urls [ 0 ], } ) ) elif \"open.spotify.com\" in request and \"track\" in request : urls . append ( request ) elif \"open.spotify.com\" in request and \"playlist\" in request : urls . extend ( Playlist . get_urls ( request )) elif \"open.spotify.com\" in request and \"album\" in request : urls . extend ( Album . get_urls ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : for album_url in Artist . get_albums ( request ): urls . extend ( Album . get_urls ( album_url )) elif request == \"saved\" : urls . extend ( Saved . get_urls ( \"saved\" )) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as m3u_file : for track in json . load ( m3u_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) with concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) as executor : for song in executor . map ( Song . from_url , urls ): songs . append ( song ) return songs","title":"search"},{"location":"reference/utils/search/#spotdl.utils.search.QueryError","text":"Bases: Exception Base class for all exceptions related to query.","title":"QueryError"},{"location":"reference/utils/search/#spotdl.utils.search.create_empty_song","text":"Create an empty song.","title":"create_empty_song()"},{"location":"reference/utils/search/#spotdl.utils.search.create_empty_song--arguments","text":"name: Name of the song artists: List of artists album_name: Name of the album album_artist: Name of the album artist genres: List of genres disc_number: Disc number disc_count: Disc count duration: Duration of the song in seconds year: Year of release date: Date of release track_number: Track number tracks_count: Number of tracks isrc: ISRC code song_id: Spotify song ID cover_url: URL of the cover art explicit: Explicit flag publisher: Publisher url: URL of the song copyright_text: Copyright text download_url: Download URL song_list: Song list","title":"Arguments"},{"location":"reference/utils/search/#spotdl.utils.search.create_empty_song--returns","text":"Song object Source code in spotdl/utils/search.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List [ str ]] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List [ str ]] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ \"SongList\" ] = None , ) -> Song : \"\"\" Create an empty song. ### Arguments - name: Name of the song - artists: List of artists - album_name: Name of the album - album_artist: Name of the album artist - genres: List of genres - disc_number: Disc number - disc_count: Disc count - duration: Duration of the song in seconds - year: Year of release - date: Date of release - track_number: Track number - tracks_count: Number of tracks - isrc: ISRC code - song_id: Spotify song ID - cover_url: URL of the cover art - explicit: Explicit flag - publisher: Publisher - url: URL of the song - copyright_text: Copyright text - download_url: Download URL - song_list: Song list ### Returns - Song object \"\"\" return Song ( name = name , # type: ignore artists = artists , # type: ignore artist = None if artists is None else artists [ 0 ], # type: ignore album_name = album_name , # type: ignore album_artist = album_artist , # type: ignore genres = genres , # type: ignore disc_number = disc_number , # type: ignore disc_count = disc_count , # type: ignore duration = duration , # type: ignore year = year , # type: ignore date = date , # type: ignore track_number = track_number , # type: ignore tracks_count = tracks_count , # type: ignore isrc = isrc , # type: ignore song_id = song_id , # type: ignore cover_url = cover_url , # type: ignore explicit = explicit , # type: ignore publisher = publisher , # type: ignore url = url , # type: ignore copyright_text = copyright_text , download_url = download_url , song_list = song_list , )","title":"Returns"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results","text":"Creates a list of Song objects from a search term.","title":"get_search_results()"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results--arguments","text":"search_term: the search term to use","title":"Arguments"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results--returns","text":"a list of Song objects Source code in spotdl/utils/search.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def get_search_results ( search_term : str ) -> List [ Song ]: \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: the search term to use ### Returns - a list of Song objects \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) songs = [] for index , _ in enumerate ( raw_search_results [ \"tracks\" ][ \"items\" ]): songs . append ( Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ index ][ \"id\" ] ) ) return songs","title":"Returns"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs","text":"Parse query and return list containing simple song objects","title":"get_simple_songs()"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs--arguments","text":"query: List of strings containing query","title":"Arguments"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs--returns","text":"List of simple song objects Source code in spotdl/utils/search.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def get_simple_songs ( query : List [ str ], ) -> List [ Song ]: \"\"\" Parse query and return list containing simple song objects ### Arguments - query: List of strings containing query ### Returns - List of simple song objects \"\"\" songs : List [ Song ] = [] lists : List [ SongList ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( 'Incorrect format used, please use \"YouTubeURL|SpotifyURL\"' ) songs . append ( create_empty_song ( url = split_urls [ 1 ], download_url = split_urls [ 0 ]) ) elif \"open.spotify.com\" in request and \"track\" in request : songs . append ( create_empty_song ( url = request )) # type: ignore elif \"open.spotify.com\" in request and \"playlist\" in request : lists . append ( Playlist . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"album\" in request : lists . append ( Album . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : lists . append ( Artist . create_basic_list ( request )) elif request == \"saved\" : lists . append ( Saved . create_basic_list ()) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as save_file : for track in json . load ( save_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) for song_list in lists : songs . extend ( [ create_empty_song ( url = url , song_list = song_list ) for url in song_list . urls ] ) # type: ignore return songs","title":"Returns"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query","text":"Parse query and return list containing song object","title":"parse_query()"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query--arguments","text":"query: List of strings containing query threads: Number of threads to use","title":"Arguments"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query--returns","text":"List of song objects Source code in spotdl/utils/search.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def parse_query ( query : List [ str ], threads : int = 1 , ) -> List [ Song ]: \"\"\" Parse query and return list containing song object ### Arguments - query: List of strings containing query - threads: Number of threads to use ### Returns - List of song objects \"\"\" urls : List [ str ] = [] songs : List [ Song ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( Song . from_dict ( { ** Song . from_url ( split_urls [ 1 ]) . json , \"download_url\" : split_urls [ 0 ], } ) ) elif \"open.spotify.com\" in request and \"track\" in request : urls . append ( request ) elif \"open.spotify.com\" in request and \"playlist\" in request : urls . extend ( Playlist . get_urls ( request )) elif \"open.spotify.com\" in request and \"album\" in request : urls . extend ( Album . get_urls ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : for album_url in Artist . get_albums ( request ): urls . extend ( Album . get_urls ( album_url )) elif request == \"saved\" : urls . extend ( Saved . get_urls ( \"saved\" )) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as m3u_file : for track in json . load ( m3u_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) with concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) as executor : for song in executor . map ( Song . from_url , urls ): songs . append ( song ) return songs","title":"Returns"},{"location":"reference/utils/spotify/","text":"Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret. import spotdl.utils.spotify spotify . Spotify . init ( client_id , client_secret ) Singleton \u00a4 Bases: type Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance. __call__ () \u00a4 Call method for Singleton metaclass. Returns \u00a4 The instance of the SpotifyClient. Source code in spotdl/utils/spotify.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __call__ ( self ): # pylint: disable=bad-mcs-method-argument \"\"\" Call method for Singleton metaclass. ### Returns - The instance of the SpotifyClient. \"\"\" if self . _instance is None : raise SpotifyError ( \"Spotify client not created. Call SpotifyClient.init\" \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\" ) return self . _instance init ( client_id , client_secret , auth_token = None , user_auth = False , cache_path = None , no_cache = False , open_browser = True ) \u00a4 Initializes the SpotifyClient. Arguments \u00a4 client_id: The client ID of the application. client_secret: The client secret of the application. auth_token: The access token to use. user_auth: Whether or not to use user authentication. cache_path: The path to the cache file. no_cache: Whether or not to use the cache. open_browser: Whether or not to open the browser. Returns \u00a4 The instance of the SpotifyClient. Source code in spotdl/utils/spotify.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def init ( # pylint: disable=bad-mcs-method-argument self , client_id : str , client_secret : str , auth_token : Optional [ str ] = None , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - auth_token: The access token to use. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed, if yes, raise an Exception if isinstance ( self . _instance , self ): raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) if auth_token is not None : credential_manager = None self . user_auth = user_auth self . no_cache = no_cache # Create instance self . _instance = super () . __call__ ( auth = auth_token , auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance SpotifyClient ( * args , ** kwargs ) \u00a4 Bases: Spotify This is the Spotify client meant to be used in the app. Has to be initialized first by calling SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) . Arguments \u00a4 auth: The access token to use. auth_manager: The auth manager to use. Source code in spotdl/utils/spotify.py 132 133 134 135 136 137 138 139 140 141 142 def __init__ ( self , * args , ** kwargs ): \"\"\" Initializes the SpotifyClient. ### Arguments - auth: The access token to use. - auth_manager: The auth manager to use. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _initialized = True SpotifyError \u00a4 Bases: Exception Base class for all exceptions related to SpotifyClient.","title":"spotify"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton","text":"Bases: type Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance.","title":"Singleton"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.__call__","text":"Call method for Singleton metaclass.","title":"__call__()"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.__call__--returns","text":"The instance of the SpotifyClient. Source code in spotdl/utils/spotify.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __call__ ( self ): # pylint: disable=bad-mcs-method-argument \"\"\" Call method for Singleton metaclass. ### Returns - The instance of the SpotifyClient. \"\"\" if self . _instance is None : raise SpotifyError ( \"Spotify client not created. Call SpotifyClient.init\" \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\" ) return self . _instance","title":"Returns"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init","text":"Initializes the SpotifyClient.","title":"init()"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init--arguments","text":"client_id: The client ID of the application. client_secret: The client secret of the application. auth_token: The access token to use. user_auth: Whether or not to use user authentication. cache_path: The path to the cache file. no_cache: Whether or not to use the cache. open_browser: Whether or not to open the browser.","title":"Arguments"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init--returns","text":"The instance of the SpotifyClient. Source code in spotdl/utils/spotify.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def init ( # pylint: disable=bad-mcs-method-argument self , client_id : str , client_secret : str , auth_token : Optional [ str ] = None , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - auth_token: The access token to use. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed, if yes, raise an Exception if isinstance ( self . _instance , self ): raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) if auth_token is not None : credential_manager = None self . user_auth = user_auth self . no_cache = no_cache # Create instance self . _instance = super () . __call__ ( auth = auth_token , auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance","title":"Returns"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyClient","text":"Bases: Spotify This is the Spotify client meant to be used in the app. Has to be initialized first by calling SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) .","title":"SpotifyClient"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyClient--arguments","text":"auth: The access token to use. auth_manager: The auth manager to use. Source code in spotdl/utils/spotify.py 132 133 134 135 136 137 138 139 140 141 142 def __init__ ( self , * args , ** kwargs ): \"\"\" Initializes the SpotifyClient. ### Arguments - auth: The access token to use. - auth_manager: The auth manager to use. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _initialized = True","title":"Arguments"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyError","text":"Bases: Exception Base class for all exceptions related to SpotifyClient.","title":"SpotifyError"}]}